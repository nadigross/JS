"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/vendor/hash-wasm/sha256.js
var import_meta, Module, sha256_default;
var init_sha256 = __esm({
  "src/vendor/hash-wasm/sha256.js"() {
    "use strict";
    import_meta = {};
    Module = (() => {
      var _unused = import_meta.url;
      return function(moduleArg = {}) {
        var Module2 = moduleArg;
        var readyPromiseResolve, readyPromiseReject;
        Module2["ready"] = new Promise((resolve3, reject) => {
          readyPromiseResolve = resolve3;
          readyPromiseReject = reject;
        });
        var moduleOverrides = Object.assign({}, Module2);
        var arguments_ = [];
        var thisProgram = "./this.program";
        var quit_ = (status, toThrow) => {
          throw toThrow;
        };
        var ENVIRONMENT_IS_WEB = typeof window == "object";
        var ENVIRONMENT_IS_WORKER = typeof importScripts == "function";
        var ENVIRONMENT_IS_NODE = typeof process == "object" && typeof process.versions == "object" && typeof process.versions.node == "string";
        var ENVIRONMENT_IS_SHELL = !ENVIRONMENT_IS_WEB && !ENVIRONMENT_IS_NODE && !ENVIRONMENT_IS_WORKER;
        var scriptDirectory = "";
        function locateFile(path2) {
          if (Module2["locateFile"]) {
            return Module2["locateFile"](path2, scriptDirectory);
          }
          return scriptDirectory + path2;
        }
        var read_, readAsync, readBinary;
        if (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) {
          if (ENVIRONMENT_IS_WORKER) {
            scriptDirectory = self.location.href;
          } else if (typeof document != "undefined" && document.currentScript) {
            scriptDirectory = document.currentScript.src;
          }
          if (false) {
            scriptDirectory = false;
          }
          if (scriptDirectory.startsWith("blob:")) {
            scriptDirectory = "";
          } else {
            scriptDirectory = scriptDirectory.substr(0, scriptDirectory.replace(/[?#].*/, "").lastIndexOf("/") + 1);
          }
          {
            read_ = (url) => {
              var xhr = new XMLHttpRequest();
              xhr.open("GET", url, false);
              xhr.send(null);
              return xhr.responseText;
            };
            if (ENVIRONMENT_IS_WORKER) {
              readBinary = (url) => {
                var xhr = new XMLHttpRequest();
                xhr.open("GET", url, false);
                xhr.responseType = "arraybuffer";
                xhr.send(null);
                return new Uint8Array(
                  /** @type{!ArrayBuffer} */
                  xhr.response
                );
              };
            }
            readAsync = (url, onload, onerror) => {
              var xhr = new XMLHttpRequest();
              xhr.open("GET", url, true);
              xhr.responseType = "arraybuffer";
              xhr.onload = () => {
                if (xhr.status == 200 || xhr.status == 0 && xhr.response) {
                  onload(xhr.response);
                  return;
                }
                onerror();
              };
              xhr.onerror = onerror;
              xhr.send(null);
            };
          }
        } else {
        }
        var out = Module2["print"] || console.log.bind(console);
        var err = Module2["printErr"] || console.error.bind(console);
        Object.assign(Module2, moduleOverrides);
        moduleOverrides = null;
        if (Module2["arguments"])
          arguments_ = Module2["arguments"];
        if (Module2["thisProgram"])
          thisProgram = Module2["thisProgram"];
        if (Module2["quit"])
          quit_ = Module2["quit"];
        var wasmBinary2;
        if (Module2["wasmBinary"])
          wasmBinary2 = Module2["wasmBinary"];
        if (typeof WebAssembly != "object") {
          abort("no native wasm support detected");
        }
        function intArrayFromBase64(s) {
          var decoded = atob(s);
          var bytes = new Uint8Array(decoded.length);
          for (var i = 0; i < decoded.length; ++i) {
            bytes[i] = decoded.charCodeAt(i);
          }
          return bytes;
        }
        function tryParseAsDataURI(filename) {
          if (!isDataURI(filename)) {
            return;
          }
          return intArrayFromBase64(filename.slice(dataURIPrefix.length));
        }
        var wasmMemory;
        var ABORT = false;
        var EXITSTATUS;
        function assert(condition, text) {
          if (!condition) {
            abort(text);
          }
        }
        var HEAP, HEAP8, HEAPU8, HEAP16, HEAPU16, HEAP32, HEAPU32, HEAPF32, HEAPF64;
        function updateMemoryViews() {
          var b = wasmMemory.buffer;
          Module2["HEAP8"] = HEAP8 = new Int8Array(b);
          Module2["HEAP16"] = HEAP16 = new Int16Array(b);
          Module2["HEAPU8"] = HEAPU8 = new Uint8Array(b);
          Module2["HEAPU16"] = HEAPU16 = new Uint16Array(b);
          Module2["HEAP32"] = HEAP32 = new Int32Array(b);
          Module2["HEAPU32"] = HEAPU32 = new Uint32Array(b);
          Module2["HEAPF32"] = HEAPF32 = new Float32Array(b);
          Module2["HEAPF64"] = HEAPF64 = new Float64Array(b);
        }
        var __ATPRERUN__ = [];
        var __ATINIT__ = [];
        var __ATEXIT__ = [];
        var __ATPOSTRUN__ = [];
        var runtimeInitialized = false;
        function preRun() {
          if (Module2["preRun"]) {
            if (typeof Module2["preRun"] == "function")
              Module2["preRun"] = [Module2["preRun"]];
            while (Module2["preRun"].length) {
              addOnPreRun(Module2["preRun"].shift());
            }
          }
          callRuntimeCallbacks(__ATPRERUN__);
        }
        function initRuntime() {
          runtimeInitialized = true;
          callRuntimeCallbacks(__ATINIT__);
        }
        function postRun() {
          if (Module2["postRun"]) {
            if (typeof Module2["postRun"] == "function")
              Module2["postRun"] = [Module2["postRun"]];
            while (Module2["postRun"].length) {
              addOnPostRun(Module2["postRun"].shift());
            }
          }
          callRuntimeCallbacks(__ATPOSTRUN__);
        }
        function addOnPreRun(cb) {
          __ATPRERUN__.unshift(cb);
        }
        function addOnInit(cb) {
          __ATINIT__.unshift(cb);
        }
        function addOnExit(cb) {
        }
        function addOnPostRun(cb) {
          __ATPOSTRUN__.unshift(cb);
        }
        var runDependencies = 0;
        var runDependencyWatcher = null;
        var dependenciesFulfilled = null;
        function getUniqueRunDependency(id) {
          return id;
        }
        function addRunDependency(id) {
          runDependencies++;
          Module2["monitorRunDependencies"]?.(runDependencies);
        }
        function removeRunDependency(id) {
          runDependencies--;
          Module2["monitorRunDependencies"]?.(runDependencies);
          if (runDependencies == 0) {
            if (runDependencyWatcher !== null) {
              clearInterval(runDependencyWatcher);
              runDependencyWatcher = null;
            }
            if (dependenciesFulfilled) {
              var callback = dependenciesFulfilled;
              dependenciesFulfilled = null;
              callback();
            }
          }
        }
        function abort(what) {
          Module2["onAbort"]?.(what);
          what = "Aborted(" + what + ")";
          err(what);
          ABORT = true;
          EXITSTATUS = 1;
          what += ". Build with -sASSERTIONS for more info.";
          var e = new WebAssembly.RuntimeError(what);
          readyPromiseReject(e);
          throw e;
        }
        var dataURIPrefix = "data:application/octet-stream;base64,";
        var isDataURI = (filename) => filename.startsWith(dataURIPrefix);
        var isFileURI = (filename) => filename.startsWith("file://");
        var wasmBinaryFile;
        wasmBinaryFile = "data:application/octet-stream;base64,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";
        if (!isDataURI(wasmBinaryFile)) {
          wasmBinaryFile = locateFile(wasmBinaryFile);
        }
        function getBinarySync(file) {
          if (file == wasmBinaryFile && wasmBinary2) {
            return new Uint8Array(wasmBinary2);
          }
          var binary = tryParseAsDataURI(file);
          if (binary) {
            return binary;
          }
          if (readBinary) {
            return readBinary(file);
          }
          throw "both async and sync fetching of the wasm failed";
        }
        function getBinaryPromise(binaryFile) {
          return Promise.resolve().then(() => getBinarySync(binaryFile));
        }
        function instantiateArrayBuffer(binaryFile, imports, receiver) {
          return getBinaryPromise(binaryFile).then((binary) => {
            return WebAssembly.instantiate(binary, imports);
          }).then(receiver, (reason) => {
            err(`failed to asynchronously prepare wasm: ${reason}`);
            abort(reason);
          });
        }
        function instantiateAsync(binary, binaryFile, imports, callback) {
          return instantiateArrayBuffer(binaryFile, imports, callback);
        }
        function createWasm() {
          var info = {
            "env": wasmImports,
            "wasi_snapshot_preview1": wasmImports
          };
          function receiveInstance(instance, module2) {
            wasmExports = instance.exports;
            wasmMemory = wasmExports["memory"];
            updateMemoryViews();
            addOnInit(wasmExports["__wasm_call_ctors"]);
            removeRunDependency("wasm-instantiate");
            return wasmExports;
          }
          addRunDependency("wasm-instantiate");
          function receiveInstantiationResult(result) {
            receiveInstance(result["instance"]);
          }
          if (Module2["instantiateWasm"]) {
            try {
              return Module2["instantiateWasm"](info, receiveInstance);
            } catch (e) {
              err(`Module.instantiateWasm callback failed with error: ${e}`);
              readyPromiseReject(e);
            }
          }
          instantiateAsync(wasmBinary2, wasmBinaryFile, info, receiveInstantiationResult).catch(readyPromiseReject);
          return {};
        }
        var tempDouble;
        var tempI64;
        function ExitStatus(status) {
          this.name = "ExitStatus";
          this.message = `Program terminated with exit(${status})`;
          this.status = status;
        }
        var callRuntimeCallbacks = (callbacks) => {
          while (callbacks.length > 0) {
            callbacks.shift()(Module2);
          }
        };
        function getValue(ptr, type = "i8") {
          if (type.endsWith("*"))
            type = "*";
          switch (type) {
            case "i1":
              return HEAP8[ptr];
            case "i8":
              return HEAP8[ptr];
            case "i16":
              return HEAP16[ptr >> 1];
            case "i32":
              return HEAP32[ptr >> 2];
            case "i64":
              abort("to do getValue(i64) use WASM_BIGINT");
            case "float":
              return HEAPF32[ptr >> 2];
            case "double":
              return HEAPF64[ptr >> 3];
            case "*":
              return HEAPU32[ptr >> 2];
            default:
              abort(`invalid type for getValue: ${type}`);
          }
        }
        var noExitRuntime = Module2["noExitRuntime"] || true;
        function setValue(ptr, value, type = "i8") {
          if (type.endsWith("*"))
            type = "*";
          switch (type) {
            case "i1":
              HEAP8[ptr] = value;
              break;
            case "i8":
              HEAP8[ptr] = value;
              break;
            case "i16":
              HEAP16[ptr >> 1] = value;
              break;
            case "i32":
              HEAP32[ptr >> 2] = value;
              break;
            case "i64":
              abort("to do setValue(i64) use WASM_BIGINT");
            case "float":
              HEAPF32[ptr >> 2] = value;
              break;
            case "double":
              HEAPF64[ptr >> 3] = value;
              break;
            case "*":
              HEAPU32[ptr >> 2] = value;
              break;
            default:
              abort(`invalid type for setValue: ${type}`);
          }
        }
        var wasmImports = {};
        var wasmExports = createWasm();
        var ___wasm_call_ctors = () => (___wasm_call_ctors = wasmExports["__wasm_call_ctors"])();
        var _Hash_Update = Module2["_Hash_Update"] = (a0) => (_Hash_Update = Module2["_Hash_Update"] = wasmExports["Hash_Update"])(a0);
        var _Hash_Final = Module2["_Hash_Final"] = () => (_Hash_Final = Module2["_Hash_Final"] = wasmExports["Hash_Final"])();
        var _Hash_Init = Module2["_Hash_Init"] = (a0) => (_Hash_Init = Module2["_Hash_Init"] = wasmExports["Hash_Init"])(a0);
        var _GetBufferPtr = Module2["_GetBufferPtr"] = () => (_GetBufferPtr = Module2["_GetBufferPtr"] = wasmExports["GetBufferPtr"])();
        var stackSave = () => (stackSave = wasmExports["stackSave"])();
        var stackRestore = (a0) => (stackRestore = wasmExports["stackRestore"])(a0);
        var stackAlloc = (a0) => (stackAlloc = wasmExports["stackAlloc"])(a0);
        var calledRun;
        dependenciesFulfilled = function runCaller() {
          if (!calledRun)
            run();
          if (!calledRun)
            dependenciesFulfilled = runCaller;
        };
        function run() {
          if (runDependencies > 0) {
            return;
          }
          preRun();
          if (runDependencies > 0) {
            return;
          }
          function doRun() {
            if (calledRun)
              return;
            calledRun = true;
            Module2["calledRun"] = true;
            if (ABORT)
              return;
            initRuntime();
            readyPromiseResolve(Module2);
            if (Module2["onRuntimeInitialized"])
              Module2["onRuntimeInitialized"]();
            postRun();
          }
          if (Module2["setStatus"]) {
            Module2["setStatus"]("Running...");
            setTimeout(function() {
              setTimeout(function() {
                Module2["setStatus"]("");
              }, 1);
              doRun();
            }, 1);
          } else {
            doRun();
          }
        }
        if (Module2["preInit"]) {
          if (typeof Module2["preInit"] == "function")
            Module2["preInit"] = [Module2["preInit"]];
          while (Module2["preInit"].length > 0) {
            Module2["preInit"].pop()();
          }
        }
        run();
        return moduleArg.ready;
      };
    })();
    sha256_default = Module;
  }
});

// src/vendor/hash-wasm/sha256-wrapper.ts
var sha256_wrapper_exports = {};
__export(sha256_wrapper_exports, {
  createSHA256: () => createSHA256,
  createSHA256WorkerCode: () => createSHA256WorkerCode
});
async function createSHA256(isInsideWorker = false) {
  const BUFFER_MAX_SIZE = 8 * 1024 * 1024;
  const wasm2 = isInsideWorker ? (
    // @ts-expect-error WasmModule will be populated inside self object
    await self["SHA256WasmModule"]()
  ) : await sha256_default();
  const heap = wasm2.HEAPU8.subarray(wasm2._GetBufferPtr());
  return {
    init() {
      wasm2._Hash_Init(256);
    },
    update(data) {
      let byteUsed = 0;
      while (byteUsed < data.byteLength) {
        const bytesLeft = data.byteLength - byteUsed;
        const length = Math.min(bytesLeft, BUFFER_MAX_SIZE);
        heap.set(data.subarray(byteUsed, byteUsed + length));
        wasm2._Hash_Update(length);
        byteUsed += length;
      }
    },
    digest(method) {
      if (method !== "hex") {
        throw new Error("Only digest hex is supported");
      }
      wasm2._Hash_Final();
      const result = Array.from(heap.slice(0, 32));
      return result.map((b) => b.toString(16).padStart(2, "0")).join("");
    }
  };
}
function createSHA256WorkerCode() {
  return `
		self.addEventListener('message', async (event) => {
      const { file } = event.data;
      const sha256 = await self.createSHA256(true);
      sha256.init();
      const reader = file.stream().getReader();
      const total = file.size;
      let bytesDone = 0;
      while (true) {
        const { done, value } = await reader.read();
        if (done) {
          break;
        }
        sha256.update(value);
        bytesDone += value.length;
        postMessage({ progress: bytesDone / total });
      }
      postMessage({ sha256: sha256.digest('hex') });
    });
    self.SHA256WasmModule = ${sha256_default.toString()};
    self.createSHA256 = ${createSHA256.toString()};
  `;
}
var init_sha256_wrapper = __esm({
  "src/vendor/hash-wasm/sha256-wrapper.ts"() {
    "use strict";
    init_sha256();
  }
});

// src/utils/sha256-node.ts
var sha256_node_exports = {};
__export(sha256_node_exports, {
  sha256Node: () => sha256Node
});
async function* sha256Node(buffer, opts) {
  const sha256Stream = (0, import_node_crypto.createHash)("sha256");
  const size = buffer instanceof Blob ? buffer.size : buffer.byteLength;
  let done = 0;
  const readable = buffer instanceof Blob ? import_node_stream.Readable.fromWeb(buffer.stream()) : import_node_stream.Readable.from(Buffer.from(buffer));
  for await (const buffer2 of readable) {
    sha256Stream.update(buffer2);
    done += buffer2.length;
    yield done / size;
    opts?.abortSignal?.throwIfAborted();
  }
  return sha256Stream.digest("hex");
}
var import_node_stream, import_node_crypto;
var init_sha256_node = __esm({
  "src/utils/sha256-node.ts"() {
    "use strict";
    import_node_stream = require("stream");
    import_node_crypto = require("crypto");
  }
});

// src/utils/FileBlob.ts
var FileBlob_exports = {};
__export(FileBlob_exports, {
  FileBlob: () => FileBlob
});
var import_node_fs, import_promises2, import_node_stream2, import_node_url, FileBlob;
var init_FileBlob = __esm({
  "src/utils/FileBlob.ts"() {
    "use strict";
    import_node_fs = require("fs");
    import_promises2 = require("fs/promises");
    import_node_stream2 = require("stream");
    import_node_url = require("url");
    FileBlob = class extends Blob {
      /**
       * Creates a new FileBlob on the provided file.
       *
       * @param path Path to the file to be lazy readed
       */
      static async create(path2) {
        path2 = path2 instanceof URL ? (0, import_node_url.fileURLToPath)(path2) : path2;
        const { size } = await (0, import_promises2.stat)(path2);
        const fileBlob = new FileBlob(path2, 0, size);
        return fileBlob;
      }
      path;
      start;
      end;
      constructor(path2, start, end) {
        super();
        this.path = path2;
        this.start = start;
        this.end = end;
      }
      /**
       * Returns the size of the blob.
       */
      get size() {
        return this.end - this.start;
      }
      /**
       * Returns a new instance of FileBlob that is a slice of the current one.
       *
       * The slice is inclusive of the start and exclusive of the end.
       *
       * The slice method does not supports negative start/end.
       *
       * @param start beginning of the slice
       * @param end end of the slice
       */
      slice(start = 0, end = this.size) {
        if (start < 0 || end < 0) {
          new TypeError("Unsupported negative start/end on FileBlob.slice");
        }
        const slice = new FileBlob(this.path, this.start + start, Math.min(this.start + end, this.end));
        return slice;
      }
      /**
       * Read the part of the file delimited by the FileBlob and returns it as an ArrayBuffer.
       */
      async arrayBuffer() {
        const slice = await this.execute((file) => file.read(Buffer.alloc(this.size), 0, this.size, this.start));
        return slice.buffer;
      }
      /**
       * Read the part of the file delimited by the FileBlob and returns it as a string.
       */
      async text() {
        const buffer = await this.arrayBuffer();
        return buffer.toString("utf8");
      }
      /**
       * Returns a stream around the part of the file delimited by the FileBlob.
       */
      stream() {
        return import_node_stream2.Readable.toWeb((0, import_node_fs.createReadStream)(this.path, { start: this.start, end: this.end - 1 }));
      }
      /**
       * We are opening and closing the file for each action to prevent file descriptor leaks.
       *
       * It is an intended choice of developer experience over performances.
       */
      async execute(action) {
        const file = await (0, import_promises2.open)(this.path, "r");
        try {
          return await action(file);
        } finally {
          await file.close();
        }
      }
    };
  }
});

// src/utils/sub-paths.ts
var sub_paths_exports = {};
__export(sub_paths_exports, {
  subPaths: () => subPaths
});
async function subPaths(path2, maxDepth = 10) {
  const state = await (0, import_promises3.stat)(path2);
  if (!state.isDirectory()) {
    return [{ path: path2, relativePath: "." }];
  }
  const files = await (0, import_promises3.readdir)(path2, { withFileTypes: true });
  const ret = [];
  for (const file of files) {
    const filePath = (0, import_node_url2.pathToFileURL)((0, import_node_url2.fileURLToPath)(path2) + "/" + file.name);
    if (file.isDirectory()) {
      ret.push(
        ...(await subPaths(filePath, maxDepth - 1)).map((subPath) => ({
          ...subPath,
          relativePath: `${file.name}/${subPath.relativePath}`
        }))
      );
    } else {
      ret.push({ path: filePath, relativePath: file.name });
    }
  }
  return ret;
}
var import_promises3, import_node_url2;
var init_sub_paths = __esm({
  "src/utils/sub-paths.ts"() {
    "use strict";
    import_promises3 = require("fs/promises");
    import_node_url2 = require("url");
  }
});

// src/vendor/xet-chunk/chunker_wasm_bg.js
var chunker_wasm_bg_exports = {};
__export(chunker_wasm_bg_exports, {
  Chunker: () => Chunker,
  __wbg_String_8f0eb39a4a4c2f66: () => __wbg_String_8f0eb39a4a4c2f66,
  __wbg_buffer_609cc3eee51ed158: () => __wbg_buffer_609cc3eee51ed158,
  __wbg_call_672a4d21634d4a24: () => __wbg_call_672a4d21634d4a24,
  __wbg_done_769e5ede4b31c67b: () => __wbg_done_769e5ede4b31c67b,
  __wbg_get_67b2ba62fc30de12: () => __wbg_get_67b2ba62fc30de12,
  __wbg_get_b9b93047fe3cf45b: () => __wbg_get_b9b93047fe3cf45b,
  __wbg_getwithrefkey_1dc361bd10053bfe: () => __wbg_getwithrefkey_1dc361bd10053bfe,
  __wbg_instanceof_ArrayBuffer_e14585432e3737fc: () => __wbg_instanceof_ArrayBuffer_e14585432e3737fc,
  __wbg_instanceof_Uint8Array_17156bcf118086a9: () => __wbg_instanceof_Uint8Array_17156bcf118086a9,
  __wbg_isArray_a1eab7e0d067391b: () => __wbg_isArray_a1eab7e0d067391b,
  __wbg_isSafeInteger_343e2beeeece1bb0: () => __wbg_isSafeInteger_343e2beeeece1bb0,
  __wbg_iterator_9a24c88df860dc65: () => __wbg_iterator_9a24c88df860dc65,
  __wbg_length_a446193dc22c12f8: () => __wbg_length_a446193dc22c12f8,
  __wbg_length_e2d2a49132c1b256: () => __wbg_length_e2d2a49132c1b256,
  __wbg_new_405e22f390576ce2: () => __wbg_new_405e22f390576ce2,
  __wbg_new_78feb108b6472713: () => __wbg_new_78feb108b6472713,
  __wbg_new_a12002a7f91c75be: () => __wbg_new_a12002a7f91c75be,
  __wbg_next_25feadfc0913fea9: () => __wbg_next_25feadfc0913fea9,
  __wbg_next_6574e1a8a62d1055: () => __wbg_next_6574e1a8a62d1055,
  __wbg_set_37837023f3d740e8: () => __wbg_set_37837023f3d740e8,
  __wbg_set_3f1d0b984ed272ed: () => __wbg_set_3f1d0b984ed272ed,
  __wbg_set_65595bdd868b3009: () => __wbg_set_65595bdd868b3009,
  __wbg_set_wasm: () => __wbg_set_wasm,
  __wbg_value_cd1ffa7b1ab794f1: () => __wbg_value_cd1ffa7b1ab794f1,
  __wbindgen_as_number: () => __wbindgen_as_number,
  __wbindgen_boolean_get: () => __wbindgen_boolean_get,
  __wbindgen_debug_string: () => __wbindgen_debug_string,
  __wbindgen_error_new: () => __wbindgen_error_new,
  __wbindgen_in: () => __wbindgen_in,
  __wbindgen_init_externref_table: () => __wbindgen_init_externref_table,
  __wbindgen_is_function: () => __wbindgen_is_function,
  __wbindgen_is_object: () => __wbindgen_is_object,
  __wbindgen_is_undefined: () => __wbindgen_is_undefined,
  __wbindgen_jsval_loose_eq: () => __wbindgen_jsval_loose_eq,
  __wbindgen_memory: () => __wbindgen_memory,
  __wbindgen_number_get: () => __wbindgen_number_get,
  __wbindgen_number_new: () => __wbindgen_number_new,
  __wbindgen_string_get: () => __wbindgen_string_get,
  __wbindgen_string_new: () => __wbindgen_string_new,
  __wbindgen_throw: () => __wbindgen_throw,
  compute_file_hash: () => compute_file_hash,
  compute_hmac: () => compute_hmac,
  compute_verification_hash: () => compute_verification_hash,
  compute_xorb_hash: () => compute_xorb_hash
});
function __wbg_set_wasm(val) {
  wasm = val;
}
function getUint8ArrayMemory0() {
  if (cachedUint8ArrayMemory0 === null || cachedUint8ArrayMemory0.byteLength === 0) {
    cachedUint8ArrayMemory0 = new Uint8Array(wasm.memory.buffer);
  }
  return cachedUint8ArrayMemory0;
}
function passStringToWasm0(arg, malloc, realloc) {
  if (realloc === void 0) {
    const buf = cachedTextEncoder.encode(arg);
    const ptr2 = malloc(buf.length, 1) >>> 0;
    getUint8ArrayMemory0().subarray(ptr2, ptr2 + buf.length).set(buf);
    WASM_VECTOR_LEN = buf.length;
    return ptr2;
  }
  let len = arg.length;
  let ptr = malloc(len, 1) >>> 0;
  const mem = getUint8ArrayMemory0();
  let offset = 0;
  for (; offset < len; offset++) {
    const code = arg.charCodeAt(offset);
    if (code > 127)
      break;
    mem[ptr + offset] = code;
  }
  if (offset !== len) {
    if (offset !== 0) {
      arg = arg.slice(offset);
    }
    ptr = realloc(ptr, len, len = offset + arg.length * 3, 1) >>> 0;
    const view = getUint8ArrayMemory0().subarray(ptr + offset, ptr + len);
    const ret = encodeString(arg, view);
    offset += ret.written;
    ptr = realloc(ptr, len, offset, 1) >>> 0;
  }
  WASM_VECTOR_LEN = offset;
  return ptr;
}
function getDataViewMemory0() {
  if (cachedDataViewMemory0 === null || cachedDataViewMemory0.buffer.detached === true || cachedDataViewMemory0.buffer.detached === void 0 && cachedDataViewMemory0.buffer !== wasm.memory.buffer) {
    cachedDataViewMemory0 = new DataView(wasm.memory.buffer);
  }
  return cachedDataViewMemory0;
}
function addToExternrefTable0(obj) {
  const idx = wasm.__externref_table_alloc();
  wasm.__wbindgen_export_4.set(idx, obj);
  return idx;
}
function handleError(f, args) {
  try {
    return f.apply(this, args);
  } catch (e) {
    const idx = addToExternrefTable0(e);
    wasm.__wbindgen_exn_store(idx);
  }
}
function debugString(val) {
  const type = typeof val;
  if (type == "number" || type == "boolean" || val == null) {
    return `${val}`;
  }
  if (type == "string") {
    return `"${val}"`;
  }
  if (type == "symbol") {
    const description = val.description;
    if (description == null) {
      return "Symbol";
    } else {
      return `Symbol(${description})`;
    }
  }
  if (type == "function") {
    const name = val.name;
    if (typeof name == "string" && name.length > 0) {
      return `Function(${name})`;
    } else {
      return "Function";
    }
  }
  if (Array.isArray(val)) {
    const length = val.length;
    let debug = "[";
    if (length > 0) {
      debug += debugString(val[0]);
    }
    for (let i = 1; i < length; i++) {
      debug += ", " + debugString(val[i]);
    }
    debug += "]";
    return debug;
  }
  const builtInMatches = /\[object ([^\]]+)\]/.exec(toString.call(val));
  let className;
  if (builtInMatches && builtInMatches.length > 1) {
    className = builtInMatches[1];
  } else {
    return toString.call(val);
  }
  if (className == "Object") {
    try {
      return "Object(" + JSON.stringify(val) + ")";
    } catch (_) {
      return "Object";
    }
  }
  if (val instanceof Error) {
    return `${val.name}: ${val.message}
${val.stack}`;
  }
  return className;
}
function getStringFromWasm0(ptr, len) {
  ptr = ptr >>> 0;
  return cachedTextDecoder.decode(getUint8ArrayMemory0().subarray(ptr, ptr + len));
}
function isLikeNone(x) {
  return x === void 0 || x === null;
}
function passArray8ToWasm0(arg, malloc) {
  const ptr = malloc(arg.length * 1, 1) >>> 0;
  getUint8ArrayMemory0().set(arg, ptr / 1);
  WASM_VECTOR_LEN = arg.length;
  return ptr;
}
function takeFromExternrefTable0(idx) {
  const value = wasm.__wbindgen_export_4.get(idx);
  wasm.__externref_table_dealloc(idx);
  return value;
}
function compute_xorb_hash(chunks_array) {
  let deferred2_0;
  let deferred2_1;
  try {
    const ret = wasm.compute_xorb_hash(chunks_array);
    var ptr1 = ret[0];
    var len1 = ret[1];
    if (ret[3]) {
      ptr1 = 0;
      len1 = 0;
      throw takeFromExternrefTable0(ret[2]);
    }
    deferred2_0 = ptr1;
    deferred2_1 = len1;
    return getStringFromWasm0(ptr1, len1);
  } finally {
    wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);
  }
}
function compute_file_hash(chunks_array) {
  let deferred2_0;
  let deferred2_1;
  try {
    const ret = wasm.compute_file_hash(chunks_array);
    var ptr1 = ret[0];
    var len1 = ret[1];
    if (ret[3]) {
      ptr1 = 0;
      len1 = 0;
      throw takeFromExternrefTable0(ret[2]);
    }
    deferred2_0 = ptr1;
    deferred2_1 = len1;
    return getStringFromWasm0(ptr1, len1);
  } finally {
    wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);
  }
}
function passArrayJsValueToWasm0(array, malloc) {
  const ptr = malloc(array.length * 4, 4) >>> 0;
  for (let i = 0; i < array.length; i++) {
    const add = addToExternrefTable0(array[i]);
    getDataViewMemory0().setUint32(ptr + 4 * i, add, true);
  }
  WASM_VECTOR_LEN = array.length;
  return ptr;
}
function compute_verification_hash(chunk_hashes) {
  let deferred3_0;
  let deferred3_1;
  try {
    const ptr0 = passArrayJsValueToWasm0(chunk_hashes, wasm.__wbindgen_malloc);
    const len0 = WASM_VECTOR_LEN;
    const ret = wasm.compute_verification_hash(ptr0, len0);
    var ptr2 = ret[0];
    var len2 = ret[1];
    if (ret[3]) {
      ptr2 = 0;
      len2 = 0;
      throw takeFromExternrefTable0(ret[2]);
    }
    deferred3_0 = ptr2;
    deferred3_1 = len2;
    return getStringFromWasm0(ptr2, len2);
  } finally {
    wasm.__wbindgen_free(deferred3_0, deferred3_1, 1);
  }
}
function compute_hmac(hash_hex, hmac_key_hex) {
  let deferred4_0;
  let deferred4_1;
  try {
    const ptr0 = passStringToWasm0(hash_hex, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
    const len0 = WASM_VECTOR_LEN;
    const ptr1 = passStringToWasm0(hmac_key_hex, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
    const len1 = WASM_VECTOR_LEN;
    const ret = wasm.compute_hmac(ptr0, len0, ptr1, len1);
    var ptr3 = ret[0];
    var len3 = ret[1];
    if (ret[3]) {
      ptr3 = 0;
      len3 = 0;
      throw takeFromExternrefTable0(ret[2]);
    }
    deferred4_0 = ptr3;
    deferred4_1 = len3;
    return getStringFromWasm0(ptr3, len3);
  } finally {
    wasm.__wbindgen_free(deferred4_0, deferred4_1, 1);
  }
}
function __wbg_String_8f0eb39a4a4c2f66(arg0, arg1) {
  const ret = String(arg1);
  const ptr1 = passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
  const len1 = WASM_VECTOR_LEN;
  getDataViewMemory0().setInt32(arg0 + 4 * 1, len1, true);
  getDataViewMemory0().setInt32(arg0 + 4 * 0, ptr1, true);
}
function __wbg_buffer_609cc3eee51ed158(arg0) {
  const ret = arg0.buffer;
  return ret;
}
function __wbg_call_672a4d21634d4a24() {
  return handleError(function(arg0, arg1) {
    const ret = arg0.call(arg1);
    return ret;
  }, arguments);
}
function __wbg_done_769e5ede4b31c67b(arg0) {
  const ret = arg0.done;
  return ret;
}
function __wbg_get_67b2ba62fc30de12() {
  return handleError(function(arg0, arg1) {
    const ret = Reflect.get(arg0, arg1);
    return ret;
  }, arguments);
}
function __wbg_get_b9b93047fe3cf45b(arg0, arg1) {
  const ret = arg0[arg1 >>> 0];
  return ret;
}
function __wbg_getwithrefkey_1dc361bd10053bfe(arg0, arg1) {
  const ret = arg0[arg1];
  return ret;
}
function __wbg_instanceof_ArrayBuffer_e14585432e3737fc(arg0) {
  let result;
  try {
    result = arg0 instanceof ArrayBuffer;
  } catch (_) {
    result = false;
  }
  const ret = result;
  return ret;
}
function __wbg_instanceof_Uint8Array_17156bcf118086a9(arg0) {
  let result;
  try {
    result = arg0 instanceof Uint8Array;
  } catch (_) {
    result = false;
  }
  const ret = result;
  return ret;
}
function __wbg_isArray_a1eab7e0d067391b(arg0) {
  const ret = Array.isArray(arg0);
  return ret;
}
function __wbg_isSafeInteger_343e2beeeece1bb0(arg0) {
  const ret = Number.isSafeInteger(arg0);
  return ret;
}
function __wbg_iterator_9a24c88df860dc65() {
  const ret = Symbol.iterator;
  return ret;
}
function __wbg_length_a446193dc22c12f8(arg0) {
  const ret = arg0.length;
  return ret;
}
function __wbg_length_e2d2a49132c1b256(arg0) {
  const ret = arg0.length;
  return ret;
}
function __wbg_new_405e22f390576ce2() {
  const ret = new Object();
  return ret;
}
function __wbg_new_78feb108b6472713() {
  const ret = new Array();
  return ret;
}
function __wbg_new_a12002a7f91c75be(arg0) {
  const ret = new Uint8Array(arg0);
  return ret;
}
function __wbg_next_25feadfc0913fea9(arg0) {
  const ret = arg0.next;
  return ret;
}
function __wbg_next_6574e1a8a62d1055() {
  return handleError(function(arg0) {
    const ret = arg0.next();
    return ret;
  }, arguments);
}
function __wbg_set_37837023f3d740e8(arg0, arg1, arg2) {
  arg0[arg1 >>> 0] = arg2;
}
function __wbg_set_3f1d0b984ed272ed(arg0, arg1, arg2) {
  arg0[arg1] = arg2;
}
function __wbg_set_65595bdd868b3009(arg0, arg1, arg2) {
  arg0.set(arg1, arg2 >>> 0);
}
function __wbg_value_cd1ffa7b1ab794f1(arg0) {
  const ret = arg0.value;
  return ret;
}
function __wbindgen_as_number(arg0) {
  const ret = +arg0;
  return ret;
}
function __wbindgen_boolean_get(arg0) {
  const v = arg0;
  const ret = typeof v === "boolean" ? v ? 1 : 0 : 2;
  return ret;
}
function __wbindgen_debug_string(arg0, arg1) {
  const ret = debugString(arg1);
  const ptr1 = passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
  const len1 = WASM_VECTOR_LEN;
  getDataViewMemory0().setInt32(arg0 + 4 * 1, len1, true);
  getDataViewMemory0().setInt32(arg0 + 4 * 0, ptr1, true);
}
function __wbindgen_error_new(arg0, arg1) {
  const ret = new Error(getStringFromWasm0(arg0, arg1));
  return ret;
}
function __wbindgen_in(arg0, arg1) {
  const ret = arg0 in arg1;
  return ret;
}
function __wbindgen_init_externref_table() {
  const table = wasm.__wbindgen_export_4;
  const offset = table.grow(4);
  table.set(0, void 0);
  table.set(offset + 0, void 0);
  table.set(offset + 1, null);
  table.set(offset + 2, true);
  table.set(offset + 3, false);
  ;
}
function __wbindgen_is_function(arg0) {
  const ret = typeof arg0 === "function";
  return ret;
}
function __wbindgen_is_object(arg0) {
  const val = arg0;
  const ret = typeof val === "object" && val !== null;
  return ret;
}
function __wbindgen_is_undefined(arg0) {
  const ret = arg0 === void 0;
  return ret;
}
function __wbindgen_jsval_loose_eq(arg0, arg1) {
  const ret = arg0 == arg1;
  return ret;
}
function __wbindgen_memory() {
  const ret = wasm.memory;
  return ret;
}
function __wbindgen_number_get(arg0, arg1) {
  const obj = arg1;
  const ret = typeof obj === "number" ? obj : void 0;
  getDataViewMemory0().setFloat64(arg0 + 8 * 1, isLikeNone(ret) ? 0 : ret, true);
  getDataViewMemory0().setInt32(arg0 + 4 * 0, !isLikeNone(ret), true);
}
function __wbindgen_number_new(arg0) {
  const ret = arg0;
  return ret;
}
function __wbindgen_string_get(arg0, arg1) {
  const obj = arg1;
  const ret = typeof obj === "string" ? obj : void 0;
  var ptr1 = isLikeNone(ret) ? 0 : passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
  var len1 = WASM_VECTOR_LEN;
  getDataViewMemory0().setInt32(arg0 + 4 * 1, len1, true);
  getDataViewMemory0().setInt32(arg0 + 4 * 0, ptr1, true);
}
function __wbindgen_string_new(arg0, arg1) {
  const ret = getStringFromWasm0(arg0, arg1);
  return ret;
}
function __wbindgen_throw(arg0, arg1) {
  throw new Error(getStringFromWasm0(arg0, arg1));
}
var wasm, WASM_VECTOR_LEN, cachedUint8ArrayMemory0, lTextEncoder, cachedTextEncoder, encodeString, cachedDataViewMemory0, lTextDecoder, cachedTextDecoder, ChunkerFinalization, Chunker;
var init_chunker_wasm_bg = __esm({
  "src/vendor/xet-chunk/chunker_wasm_bg.js"() {
    "use strict";
    WASM_VECTOR_LEN = 0;
    cachedUint8ArrayMemory0 = null;
    lTextEncoder = typeof TextEncoder === "undefined" ? (0, module.require)("util").TextEncoder : TextEncoder;
    cachedTextEncoder = new lTextEncoder("utf-8");
    encodeString = typeof cachedTextEncoder.encodeInto === "function" ? function(arg, view) {
      return cachedTextEncoder.encodeInto(arg, view);
    } : function(arg, view) {
      const buf = cachedTextEncoder.encode(arg);
      view.set(buf);
      return {
        read: arg.length,
        written: buf.length
      };
    };
    cachedDataViewMemory0 = null;
    lTextDecoder = typeof TextDecoder === "undefined" ? (0, module.require)("util").TextDecoder : TextDecoder;
    cachedTextDecoder = new lTextDecoder("utf-8", { ignoreBOM: true, fatal: true });
    cachedTextDecoder.decode();
    ChunkerFinalization = typeof FinalizationRegistry === "undefined" ? { register: () => {
    }, unregister: () => {
    } } : new FinalizationRegistry((ptr) => wasm.__wbg_chunker_free(ptr >>> 0, 1));
    Chunker = class {
      __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        ChunkerFinalization.unregister(this);
        return ptr;
      }
      free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_chunker_free(ptr, 0);
      }
      /**
       * @param {number} target_chunk_size
       */
      constructor(target_chunk_size) {
        const ret = wasm.chunker_new(target_chunk_size);
        this.__wbg_ptr = ret >>> 0;
        ChunkerFinalization.register(this, this.__wbg_ptr, this);
        return this;
      }
      /**
       * @param {Uint8Array} data
       * @returns {any}
       */
      add_data(data) {
        const ptr0 = passArray8ToWasm0(data, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.chunker_add_data(this.__wbg_ptr, ptr0, len0);
        if (ret[2]) {
          throw takeFromExternrefTable0(ret[1]);
        }
        return takeFromExternrefTable0(ret[0]);
      }
      /**
       * @returns {any}
       */
      finish() {
        const ret = wasm.chunker_finish(this.__wbg_ptr);
        if (ret[2]) {
          throw takeFromExternrefTable0(ret[1]);
        }
        return takeFromExternrefTable0(ret[0]);
      }
    };
  }
});

// src/vendor/xet-chunk/chunker_wasm_bg.wasm.base64.ts
var wasmBase64, wasmBinary;
var init_chunker_wasm_bg_wasm_base64 = __esm({
  "src/vendor/xet-chunk/chunker_wasm_bg.wasm.base64.ts"() {
    "use strict";
    wasmBase64 = atob(
      `
AGFzbQEAAAABxQIvYAJ/fwF/YAN/f38Bf2ACf38AYAN/f38AYAR/f39/AGABfwBgAW8Bf2ABfwF/
YAAEf39/f2AFf39/f38AYAFvAW9gAn9vAGAAAW9gAABgBn9/f39/fwBgAAN/f39gAm9vAW9gBn9/
f39/fwF/YAV/f39/fwF/YAR/f39/AX9gAn9/AW9gAm9vAX9gAAF/YAFvBH9/f39gAW8BfGABfAFv
YANvb28AYAJvfwFvYANvf28AYANvb38AYAV/f39+fwBgB39/f35/f38Bf2AJf39/f39/fn5+AGAH
f39/f39/fwF/YAN/fn8AYAN/fn4AYAR/f39/BH9/f39gAn9/BH9/f39gA39/fwN/f39gAX8Df39/
YAV/f3x/fwBgBH98f38AYAV/f35/fwBgBH9+f38AYAV/f31/fwBgBH99f38AYAJ/fgF+Ar8QJxgu
L2hmX3hldF90aGluX3dhc21fYmcuanMVX193YmluZGdlbl9zdHJpbmdfbmV3ABQYLi9oZl94ZXRf
dGhpbl93YXNtX2JnLmpzFF9fd2JpbmRnZW5fZXJyb3JfbmV3ABQYLi9oZl94ZXRfdGhpbl93YXNt
X2JnLmpzFV9fd2JpbmRnZW5fc3RyaW5nX2dldAALGC4vaGZfeGV0X3RoaW5fd2FzbV9iZy5qcxRf
X3diaW5kZ2VuX2lzX29iamVjdAAGGC4vaGZfeGV0X3RoaW5fd2FzbV9iZy5qcxdfX3diaW5kZ2Vu
X2lzX3VuZGVmaW5lZAAGGC4vaGZfeGV0X3RoaW5fd2FzbV9iZy5qcw1fX3diaW5kZ2VuX2luABUY
Li9oZl94ZXRfdGhpbl93YXNtX2JnLmpzGV9fd2JpbmRnZW5fanN2YWxfbG9vc2VfZXEAFRguL2hm
X3hldF90aGluX3dhc21fYmcuanMWX193YmluZGdlbl9ib29sZWFuX2dldAAGGC4vaGZfeGV0X3Ro
aW5fd2FzbV9iZy5qcxVfX3diaW5kZ2VuX251bWJlcl9nZXQACxguL2hmX3hldF90aGluX3dhc21f
YmcuanMUX193YmluZGdlbl9hc19udW1iZXIAGBguL2hmX3hldF90aGluX3dhc21fYmcuanMdX193
YmdfU3RyaW5nXzhmMGViMzlhNGE0YzJmNjYACxguL2hmX3hldF90aGluX3dhc21fYmcuanMVX193
YmluZGdlbl9udW1iZXJfbmV3ABkYLi9oZl94ZXRfdGhpbl93YXNtX2JnLmpzJF9fd2JnX2dldHdp
dGhyZWZrZXlfMWRjMzYxYmQxMDA1M2JmZQAQGC4vaGZfeGV0X3RoaW5fd2FzbV9iZy5qcxpfX3di
Z19zZXRfM2YxZDBiOTg0ZWQyNzJlZAAaGC4vaGZfeGV0X3RoaW5fd2FzbV9iZy5qcxpfX3diZ19n
ZXRfYjliOTMwNDdmZTNjZjQ1YgAbGC4vaGZfeGV0X3RoaW5fd2FzbV9iZy5qcx1fX3diZ19sZW5n
dGhfZTJkMmE0OTEzMmMxYjI1NgAGGC4vaGZfeGV0X3RoaW5fd2FzbV9iZy5qcxpfX3diZ19uZXdf
NzhmZWIxMDhiNjQ3MjcxMwAMGC4vaGZfeGV0X3RoaW5fd2FzbV9iZy5qcxZfX3diaW5kZ2VuX2lz
X2Z1bmN0aW9uAAYYLi9oZl94ZXRfdGhpbl93YXNtX2JnLmpzG19fd2JnX25leHRfMjVmZWFkZmMw
OTEzZmVhOQAKGC4vaGZfeGV0X3RoaW5fd2FzbV9iZy5qcxtfX3diZ19uZXh0XzY1NzRlMWE4YTYy
ZDEwNTUAChguL2hmX3hldF90aGluX3dhc21fYmcuanMbX193YmdfZG9uZV83NjllNWVkZTRiMzFj
NjdiAAYYLi9oZl94ZXRfdGhpbl93YXNtX2JnLmpzHF9fd2JnX3ZhbHVlX2NkMWZmYTdiMWFiNzk0
ZjEAChguL2hmX3hldF90aGluX3dhc21fYmcuanMfX193YmdfaXRlcmF0b3JfOWEyNGM4OGRmODYw
ZGM2NQAMGC4vaGZfeGV0X3RoaW5fd2FzbV9iZy5qcxpfX3diZ19nZXRfNjdiMmJhNjJmYzMwZGUx
MgAQGC4vaGZfeGV0X3RoaW5fd2FzbV9iZy5qcxtfX3diZ19jYWxsXzY3MmE0ZDIxNjM0ZDRhMjQA
EBguL2hmX3hldF90aGluX3dhc21fYmcuanMaX193YmdfbmV3XzQwNWUyMmYzOTA1NzZjZTIADBgu
L2hmX3hldF90aGluX3dhc21fYmcuanMaX193Ymdfc2V0XzM3ODM3MDIzZjNkNzQwZTgAHBguL2hm
X3hldF90aGluX3dhc21fYmcuanMeX193YmdfaXNBcnJheV9hMWVhYjdlMGQwNjczOTFiAAYYLi9o
Zl94ZXRfdGhpbl93YXNtX2JnLmpzLV9fd2JnX2luc3RhbmNlb2ZfQXJyYXlCdWZmZXJfZTE0NTg1
NDMyZTM3MzdmYwAGGC4vaGZfeGV0X3RoaW5fd2FzbV9iZy5qcyRfX3diZ19pc1NhZmVJbnRlZ2Vy
XzM0M2UyYmVlZWVjZTFiYjAABhguL2hmX3hldF90aGluX3dhc21fYmcuanMdX193YmdfYnVmZmVy
XzYwOWNjM2VlZTUxZWQxNTgAChguL2hmX3hldF90aGluX3dhc21fYmcuanMaX193YmdfbmV3X2Ex
MjAwMmE3ZjkxYzc1YmUAChguL2hmX3hldF90aGluX3dhc21fYmcuanMaX193Ymdfc2V0XzY1NTk1
YmRkODY4YjMwMDkAHRguL2hmX3hldF90aGluX3dhc21fYmcuanMdX193YmdfbGVuZ3RoX2E0NDYx
OTNkYzIyYzEyZjgABhguL2hmX3hldF90aGluX3dhc21fYmcuanMsX193YmdfaW5zdGFuY2VvZl9V
aW50OEFycmF5XzE3MTU2YmNmMTE4MDg2YTkABhguL2hmX3hldF90aGluX3dhc21fYmcuanMXX193
YmluZGdlbl9kZWJ1Z19zdHJpbmcACxguL2hmX3hldF90aGluX3dhc21fYmcuanMQX193YmluZGdl
bl90aHJvdwACGC4vaGZfeGV0X3RoaW5fd2FzbV9iZy5qcxFfX3diaW5kZ2VuX21lbW9yeQAMGC4v
aGZfeGV0X3RoaW5fd2FzbV9iZy5qcx9fX3diaW5kZ2VuX2luaXRfZXh0ZXJucmVmX3RhYmxlAA0D
zAHKAR4HHwIAAgIAAwkDBBEDAwAFAQAAAQERAQQCIAECABYHAg4OISIDAAIAAAAWCQMAAgQEAwME
AQcACQICAwUCAgMDBQIDDg4AAgIDBAAAAgQAIwkDAQMCBwAABAQEAwAEAAEBBQQNAQAFAAACAwQC
AAASBQAkACUmFxcCJxMRBwkoKhIsBQQAAQQuAAUDAwAFAAAHEwADAQAJAAAEBAAABQICAgAAAAID
AwcDAwMFAAAAAAAAAAAAAA0NAgACAAACAAECAAACBwcHBwMECQJwAWdnbwCAAQUDAQARBgkBfwFB
gIDAAAsH3wIRBm1lbW9yeQIAEl9fd2JnX2NodW5rZXJfZnJlZQBkC2NodW5rZXJfbmV3AEYQY2h1
bmtlcl9hZGRfZGF0YQCdAQ5jaHVua2VyX2ZpbmlzaAChARFjb21wdXRlX3hvcmJfaGFzaACeARFj
b21wdXRlX2ZpbGVfaGFzaACfARljb21wdXRlX3ZlcmlmaWNhdGlvbl9oYXNoAJwBDGNvbXB1dGVf
aG1hYwCaARFfX3diaW5kZ2VuX21hbGxvYwCbARJfX3diaW5kZ2VuX3JlYWxsb2MAogEUX193Ymlu
ZGdlbl9leG5fc3RvcmUAxQEXX19leHRlcm5yZWZfdGFibGVfYWxsb2MARRNfX3diaW5kZ2VuX2V4
cG9ydF80AQEZX19leHRlcm5yZWZfdGFibGVfZGVhbGxvYwBoD19fd2JpbmRnZW5fZnJlZQC7ARBf
X3diaW5kZ2VuX3N0YXJ0ACYJuwEBAEEBC2bZAdoBugGxAYcBT9sB1QG9ATa/AdcB6QHWAeoB2AGx
AYcBT7EBhwFPvQFtlgGoAWylAagBowGtAasBpQGlAakBpgGnAa4BgAF17wHwAYEBhQFYpAFnggGK
AVtq3AGTAcEBwgHPAXlzwwG/AYQBrAGVAYYBXlXEAZABXLAB3QG1AcMBjwF8sQGIAVDhAcYBxwHJ
AZEByAHiAaoBdlZl6wGxAYwBUeMB5AHmAb0BygHLAZkBctQBDAETCtjcBMoBiRsBIH8gACAAKAIY
Ih0gASgAECIkIAAoAghqaiIbIAEoABQiFWogHSAbIAJB/wFxc0EQdyICQfLmu+MDaiIdc0EUdyIb
aiIiIAJzQRh3IgkgHWoiHCAbc0EZdyIPIAAoAhQiGyABKAAIIgIgACgCBGpqIhkgASgADCIdaiAZ
IANCIIinc0EQdyIeQfui4aQEayIgIBtzQRR3IgZqIgogASgAKCIbamoiIyABKAAsIhlqIA8gIyAA
KAIQIiEgASgAACIPIAAoAgBqaiIIIAEoAAQiH2ogISAIIAOnc0EQdyIhQefMp9AGaiIIc0EUdyIH
aiIOICFzQRh3Ig1zQRB3IgsgACgCHCIFIAEoABgiIyAAKAIMamoiDCABKAAcIiFqIAUgDCAEQf8B
cXNBEHciBEHGlcDVBWsiBXNBFHciDGoiESAEc0EYdyIQIAVqIgVqIhJzQRR3IhRqIhMgHWogBiAg
IAogHnNBGHciIGoiBnNBGXciCiAOIAEoACAiBGpqIg4gASgAJCIeaiAKIBwgDiAQc0EQdyIcaiIK
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
DCAAIAI2AggMAQsgAUEUaiABQRBqIAAbIQMDQCADIQYgAiIAQRRqIABBEGogACgCFCICGyEDIABB
FEEQIAIbaigCACICDQALIAZBADYCAAsgB0UNBAJAIAEoAhxBAnRBiPLAAGoiAigCACABRwRAIAEg
BygCEEcEQCAHIAA2AhQgAA0CDAcLIAcgADYCECAADQEMBgsgAiAANgIAIABFDQQLIAAgBzYCGCAB
KAIQIgIEQCAAIAI2AhAgAiAANgIYCyABKAIUIgJFDQQgACACNgIUIAIgADYCGAwECyAAKAIEQXhx
IAVrIgIgBCACIARJIgIbIQQgACABIAIbIQEgACECDAALAAsCQEECIAB0IgNBACADa3IgASAAdHFo
IgZBA3QiAUGY88AAaiIDIAFBoPPAAGooAgAiACgCCCIERwRAIAQgAzYCDCADIAQ2AggMAQtBoPXA
ACACQX4gBndxNgIACyAAIAVBA3I2AgQgACAFaiIGIAEgBWsiA0EBcjYCBCAAIAFqIAM2AgBBqPXA
ACgCACIEBEAgBEF4cUGY88AAaiEBQbD1wAAoAgAhAgJ/QaD1wAAoAgAiBUEBIARBA3Z0IgRxRQRA
QaD1wAAgBCAFcjYCACABDAELIAEoAggLIQQgASACNgIIIAQgAjYCDCACIAE2AgwgAiAENgIIC0Gw
9cAAIAY2AgBBqPXAACADNgIAIABBCGoMCAtBpPXAAEGk9cAAKAIAQX4gASgCHHdxNgIACwJAAkAg
BEEQTwRAIAEgBUEDcjYCBCABIAVqIgMgBEEBcjYCBCADIARqIAQ2AgBBqPXAACgCACIGRQ0BIAZB
eHFBmPPAAGohAEGw9cAAKAIAIQICf0Gg9cAAKAIAIgVBASAGQQN2dCIGcUUEQEGg9cAAIAUgBnI2
AgAgAAwBCyAAKAIICyEGIAAgAjYCCCAGIAI2AgwgAiAANgIMIAIgBjYCCAwBCyABIAQgBWoiAEED
cjYCBCAAIAFqIgAgACgCBEEBcjYCBAwBC0Gw9cAAIAM2AgBBqPXAACAENgIACyABQQhqDAYLIAAg
AnJFBEBBACECQQIgB3QiAEEAIABrciAJcSIARQ0DIABoQQJ0QYjywABqKAIAIQALIABFDQELA0Ag
ACACIAAoAgRBeHEiAyAFayIGIARJIgcbIQkgACgCECIBRQRAIAAoAhQhAQsgAiAJIAMgBUkiABsh
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
9cAAQaz1wAAoAgAgBWoiATYCACAAIAFBAXI2AgQMAQtBsPXAACAANgIAQaj1wABBqPXAACgCACAF
aiIBNgIAIAAgAUEBcjYCBCAAIAFqIAE2AgALIAJBCGoMAwtBAEGs9cAAKAIAIgAgBU0NAhpBrPXA
ACAAIAVrIgE2AgBBtPXAAEG09cAAKAIAIgAgBWoiAjYCACACIAFBAXI2AgQgACAFQQNyNgIEIABB
CGoMAgtBpPXAAEGk9cAAKAIAQX4gAigCHHdxNgIACwJAIARBEE8EQCACIAVBA3I2AgQgAiAFaiIA
IARBAXI2AgQgACAEaiAENgIAIARBgAJPBEAgACAEEE4MAgsgBEH4AXFBmPPAAGohAQJ/QaD1wAAo
AgAiA0EBIARBA3Z0IgRxRQRAQaD1wAAgAyAEcjYCACABDAELIAEoAggLIQMgASAANgIIIAMgADYC
DCAAIAE2AgwgACADNgIIDAELIAIgBCAFaiIAQQNyNgIEIAAgAmoiACAAKAIEQQFyNgIECyACQQhq
CyAIQRBqJAAL1QwCDX8BfiMAQaACayIHJAACQAJAAkACQAJAIAFBgAhNBEAgB0EANgKIASABIAFB
ACABQYAIRxsiDGsiDkGACE8EQCAHQQE2AogBIAcgADYCjAFBASEKCyAHQYwBaiELIAMhFCAFIQEj
AEEgayIIJAAgBkEFdiIJIAogCSAKSRsiDQRAIARBAnIhDyAEQQFyIRADQCALKAIAIQkgCEEYaiIR
IAJBGGopAgA3AwAgCEEQaiISIAJBEGopAgA3AwAgCEEIaiITIAJBCGopAgA3AwAgCCACKQIANwMA
IAggCUHAACAUIBAQJyAIIAlBQGtBwAAgFCAEECcgCCAJQYABakHAACAUIAQQJyAIIAlBwAFqQcAA
IBQgBBAnIAggCUGAAmpBwAAgFCAEECcgCCAJQcACakHAACAUIAQQJyAIIAlBgANqQcAAIBQgBBAn
IAggCUHAA2pBwAAgFCAEECcgCCAJQYAEakHAACAUIAQQJyAIIAlBwARqQcAAIBQgBBAnIAggCUGA
BWpBwAAgFCAEECcgCCAJQcAFakHAACAUIAQQJyAIIAlBgAZqQcAAIBQgBBAnIAggCUHABmpBwAAg
FCAEECcgCCAJQYAHakHAACAUIAQQJyAIIAlBwAdqQcAAIBQgDxAnIAFBGGogESkDADcAACABQRBq
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
IQggBSEDDAELCyADQShBkOzAABB7AAsgA0EoQZDswAAQewALIAVBKEGQ7MAAENEBAAsgBUEoQZDs
wAAQ0QEACyAAIAlBoAH8CgAAIAAgCDYCoAEgCUGgAWokAAvkCAIKfwF+IwBBgAJrIgQkACAEIAEp
ABg3AhggBCABKQAQNwIQIAQgASkACDcCCCAEIAEpAAA3AgACfyADQYEITwRAIARBIGohBSMAQeAA
ayIBJAAgAUE4aiIGQgA3AwAgAUEwaiIHQgA3AwAgAUEoaiIIQgA3AwAgAUEgaiIJQgA3AwAgAUEY
aiIKQgA3AwAgAUEQaiILQgA3AwAgAUEIaiIMQgA3AwAgAUIANwMAIAIgAyAEQgBBECABQcAAECkh
AyABQdgAakIANwMAIAFB0ABqQgA3AwAgAUHIAGpCADcDACABQgA3A0ACQAJAAkACQCADQQNPBEAD
QCADQQV0IgJBwQBPDQIgASACIARBECABQUBrIg1BIBA9IgNBBXQiAkHBAE8NAyACQSFPDQQgAgRA
IAEgDSAC/AoAAAsgA0ECSw0ACwsgBSABKQMANwAAIAVBOGogBikDADcAACAFQTBqIAcpAwA3AAAg
BUEoaiAIKQMANwAAIAVBIGogCSkDADcAACAFQRhqIAopAwA3AAAgBUEQaiALKQMANwAAIAVBCGog
DCkDADcAACABQeAAaiQADAMLIAJBwABB/LPAABDRAQALIAJBwABBjLTAABDRAQALIAJBIEGctMAA
ENEBAAsgBEH4AGogBEEYaikCADcDACAEQfAAaiAEQRBqKQIANwMAIARB6ABqIARBCGopAgA3AwAg
BCAEKQIANwNgQcAAIQNBFAwBCyAEQcgBakIANwMAIARBwAFqQgA3AwAgBEG4AWpCADcDACAEQbAB
akIANwMAIARBqAFqQgA3AwAgBEGYAWpCADcDACAEQRA6APoBIARBoAFqQgA3AwAgBEHYAWoiBSAE
QQhqKQIANwMAIARB6AFqIgYgBEEYaikCADcDACAEQeABaiIHIARBEGopAgA3AwAgBEIANwOQASAE
IAQpAgA3A9ABIARBADsB+AEgBEIANwPwASAEQZABaiACIAMQQiEBIARB6ABqIAUpAwA3AwAgBEHw
AGogBykDADcDACAEQfgAaiAGKQMANwMAIARBKGogAUEIaikDADcDACAEQTBqIAFBEGopAwA3AwAg
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
AEEMELwBDAkLIAFB4rbAAEEOELwBDAgLIAFB8LbAAEEIELwBDAcLIAFB+LbAAEEDELwBDAYLIAFB
+7bAAEEEELwBDAULIAFB/7bAAEEMELwBDAQLIAFBi7fAAEEPELwBDAMLIAFBmrfAAEENELwBDAIL
IAFBp7fAAEEOELwBDAELIAEgACgCBCAAKAIIELwBCyACQTBqJAAL/gUBBX8gAEEIayIBIABBBGso
AgAiA0F4cSIAaiECAkACQCADQQFxDQAgA0ECcUUNASABKAIAIgMgAGohACABIANrIgFBsPXAACgC
AEYEQCACKAIEQQNxQQNHDQFBqPXAACAANgIAIAIgAigCBEF+cTYCBCABIABBAXI2AgQgAiAANgIA
DwsgASADEEcLAkACQAJAAkACQCACKAIEIgNBAnFFBEAgAkG09cAAKAIARg0CIAJBsPXAACgCAEYN
AyACIANBeHEiAhBHIAEgACACaiIAQQFyNgIEIAAgAWogADYCACABQbD1wAAoAgBHDQFBqPXAACAA
NgIADwsgAiADQX5xNgIEIAEgAEEBcjYCBCAAIAFqIAA2AgALIABBgAJJDQIgASAAEE5BACEBQcj1
wABByPXAACgCAEEBayIANgIAIAANBEGQ88AAKAIAIgAEQANAIAFBAWohASAAKAIIIgANAAsLQcj1
wABB/x8gASABQf8fTRs2AgAPC0G09cAAIAE2AgBBrPXAAEGs9cAAKAIAIABqIgA2AgAgASAAQQFy
NgIEQbD1wAAoAgAgAUYEQEGo9cAAQQA2AgBBsPXAAEEANgIACyAAQcD1wAAoAgAiA00NA0G09cAA
KAIAIgJFDQNBACEAQaz1wAAoAgAiBEEpSQ0CQYjzwAAhAQNAIAIgASgCACIFTwRAIAIgBSABKAIE
akkNBAsgASgCCCEBDAALAAtBsPXAACABNgIAQaj1wABBqPXAACgCACAAaiIANgIAIAEgAEEBcjYC
BCAAIAFqIAA2AgAPCyAAQfgBcUGY88AAaiECAn9BoPXAACgCACIDQQEgAEEDdnQiAHFFBEBBoPXA
ACAAIANyNgIAIAIMAQsgAigCCAshACACIAE2AgggACABNgIMIAEgAjYCDCABIAA2AggPC0GQ88AA
KAIAIgEEQANAIABBAWohACABKAIIIgENAAsLQcj1wABB/x8gACAAQf8fTRs2AgAgAyAETw0AQcD1
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
IAAgAzYCBCAAIAE2AgAPCyAAQQA2AgALpwMBAn8CQAJAAkACQCAALQBoIgMEQCADQcEATw0DIAJB
wAAgA2siBCACIARJGyIEBEAgACADaiABIAT8CgAACyAAIAAtAGggBGoiAzoAaCABIARqIQEgAiAE
ayICRQRAQQAhAgwCCyAAQUBrIABBwAAgACkDYCAALQBqIAAtAGlFchAnIABCADcDACAAQQA6AGgg
AEEIakIANwMAIABBEGpCADcDACAAQRhqQgA3AwAgAEEgakIANwMAIABBKGpCADcDACAAQTBqQgA3
AwAgAEE4akIANwMAIAAgAC0AaUEBajoAaQtBACEDIAJBwQBJDQEgAEFAayEEIAAtAGkhAwNAIAQg
AUHAACAAKQNgIAAtAGogA0H/AXFFchAnIAAgAC0AaUEBaiIDOgBpIAFBQGshASACQUBqIgJBwABL
DQALIAAtAGghAwsgA0H/AXEiA0HBAE8NAgsgAkHAACADayIEIAIgBEkbIgIEQCAAIANqIAEgAvwK
AAALIAAgAC0AaCACajoAaCAADwsgA0HAAEHsssAAENABAAsgA0HAAEHsssAAENABAAuGAwEHfyMA
QRBrIgQkAAJAAkACQAJAIAEoAgQiAgRAIAEoAgAhBiACQQNxIQUCQCACQQRJBEBBACECDAELIAZB
HGohAyACQXxxIQhBACECA0AgAygCACADQQhrKAIAIANBEGsoAgAgA0EYaygCACACampqaiECIANB
IGohAyAIIAdBBGoiB0cNAAsLIAUEQCAHQQN0IAZqQQRqIQMDQCADKAIAIAJqIQIgA0EIaiEDIAVB
AWsiBQ0ACwsgASgCDEUNAiACQQ9LDQEgBigCBA0BDAMLQQAhAiABKAIMRQ0CCyACQQAgAkEAShtB
AXQhAgtBACEFIAJBAE4EQCACRQ0BQQEhBSACQQEQwAEiAw0CCyAFIAJB1L3AABCzAQALQQEhA0EA
IQILIARBADYCCCAEIAM2AgQgBCACNgIAIARBkL3AACABEDtFBEAgACAEKQIANwIAIABBCGogBEEI
aigCADYCACAEQRBqJAAPC0H0vcAAQdYAIARBD2pB5L3AAEHMvsAAEHgAC+cCAQV/AkAgAUHN/3tB
ECAAIABBEE0bIgBrTw0AIABBECABQQtqQXhxIAFBC0kbIgRqQQxqECgiAkUNACACQQhrIQECQCAA
QQFrIgMgAnFFBEAgASEADAELIAJBBGsiBSgCACIGQXhxIAIgA2pBACAAa3FBCGsiAiAAQQAgAiAB
a0EQTRtqIgAgAWsiAmshAyAGQQNxBEAgACADIAAoAgRBAXFyQQJyNgIEIAAgA2oiAyADKAIEQQFy
NgIEIAUgAiAFKAIAQQFxckECcjYCACABIAJqIgMgAygCBEEBcjYCBCABIAIQQAwBCyABKAIAIQEg
ACADNgIEIAAgASACajYCAAsCQCAAKAIEIgFBA3FFDQAgAUF4cSICIARBEGpNDQAgACAEIAFBAXFy
QQJyNgIEIAAgBGoiASACIARrIgRBA3I2AgQgACACaiICIAIoAgRBAXI2AgQgASAEEEALIABBCGoh
AwsgAwvsAgEKfyMAQSBrIgIkABBSIgAoAhAhBSAAKAIMIQcgAEIANwIMIAAoAgQhBiAAKAIIIQMg
AEIENwIEIAAoAgAhASAAQQA2AgACQAJAIAMgB0YEQAJAIAEgA0YEQNBvQYABIAEgAUGAAU0bIgj8
DwEiBEF/Rg0EAkAgBUUEQCAEIQUMAQsgASAFaiAERw0FCyABIAhqIgRB/////wFLDQQgAiABBH8g
AiAGNgIUIAIgAUECdDYCHEEEBUEACzYCGCACQQhqIARBAnQgAkEUahBmIAIoAghBAUYNBCACKAIM
IQYgBCEBDAELIAEgA00NAwsgBiADQQJ0aiADQQFqIgM2AgAgACgCBCEEIAAoAgAhCAwBC0EEIQQg
AyAHTQ0BCyAGIAdBAnRqKAIAIQkgACAFNgIQIAAgCTYCDCAAIAM2AgggACAGNgIEIAAgATYCACAI
BEAgBCAIQQJ0EMwBCyACQSBqJAAgBSAHag8LAAvaCAEIfyMAQYABayICJAAgAkEIaiEFIwBBMGsi
AyQAIAMgAGkiATYCDAJAAkACQAJAAkACQCABQQFGBEAgAEHAAE0NASADQbzxwAA2AihBwPHAAC0A
AEEDRwR/IAMgA0EoajYCLCADIANBLGo2AhAgA0EQaiEEIwBBIGsiASQAAkACQAJAAkACQAJAQcDx
wAAtAABBAWsOAwIEAQALQcDxwABBAjoAACAEKAIAIgYoAgAhBCAGQQA2AgAgBEUNAiAEKAIAQQg2
AgBBwPHAAEEDOgAACyABQSBqJAAMAwsgAUEANgIYIAFBATYCDCABQbibwAA2AggMCQtBgJzAABDT
AQALIAFBADYCGCABQQE2AgwgAUH4m8AANgIIDAcLIAMoAigFQbzxwAALKAIAIgFFDQIgA0G08cAA
NgIoIAAgAW4iBkG48cAALQAAQQNHBH8gAyADQShqNgIsIAMgA0EsajYCECADQRBqIQQjAEEgayIB
JAACQAJAAkACQAJAAkBBuPHAAC0AAEEBaw4DAgQBAAtBuPHAAEECOgAAIAQoAgAiCCgCACEEIAhB
ADYCACAERQ0CIAQoAgBBAjYCAEG48cAAQQM6AAALIAFBIGokAAwDCyABQQA2AhggAUEBNgIMIAFB
uJvAADYCCAwJC0GAnMAAENMBAAsgAUEANgIYIAFBATYCDCABQfibwAA2AggMBwsgAygCKAVBtPHA
AAsoAgAgAGwiAU8NAyABQQBIDQRBASEHIAFBARDAASIERQ0EIAUgATYCHCAFIAY2AhggBUGQnMAA
NgIIIAVCADcDACAFQQA2AiggBSAENgIkIAUgATYCICAFIABBAWsiAK0gAGdBIHOthjcDECADQTBq
JAAMBgsgA0EANgIQIwBBEGsiACQAIABB8JjAADYCDCAAIANBDGo2AgggAEEIakH0rcAAIABBDGpB
9K3AACADQRBqQYyawAAQSAALQfSYwABBKEGcmcAAEJIBAAtBrJnAABCYAQALQbyZwABBL0HsmcAA
EJIBAAsgByABQfyZwAAQswEACyABQgQ3AhAgAUEIakH8msAAEKABAAsgAkE4aiIAQQA6AAAgAkH4
AGogACkDADcCACACQfAAaiACQTBqKQMANwIAIAJB6ABqIAJBKGopAwA3AgAgAkHgAGogAkEgaikD
ADcCACACQdgAaiACQRhqKQMANwIAIAJB0ABqIAJBEGopAwA3AgAgAiACKQMINwJIQcgAQQgQwAEi
AEUEQEEIQcgAEOUBAAsgAEEANgIIIABCgYCAgBA3AwAgACACKQJENwIMIABBFGogAkHMAGopAgA3
AgAgAEEcaiACQdQAaikCADcCACAAQSRqIAJB3ABqKQIANwIAIABBLGogAkHkAGopAgA3AgAgAEE0
aiACQewAaikCADcCACAAQTxqIAJB9ABqKQIANwIAIABBxABqIAJB/ABqKAIANgIAIAJBgAFqJAAg
AEEIaguCAwEEfyAAKAIMIQICQAJAAkAgAUGAAk8EQCAAKAIYIQMCQAJAIAAgAkYEQCAAQRRBECAA
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
3KzAADYCCAwCC0GkrcAAENMBAAsgAEEANgIYIABBATYCDCAAQZytwAA2AggLIABCBDcCECAAQQhq
QZCswAAQoAEACyABKAIEBUHI8cAACykDABCvASABQRBqJABQC14BAX8jAEEwayICJAAgAiABNgIM
IAIgADYCCCACQQI2AhQgAkHklcAANgIQIAJCATcCHCACIAJBCGqtQoCAgICwAYQ3AyggAiACQShq
NgIYIAJBEGoQXSACQTBqJAALXgEBfyMAQTBrIgIkACACIAE2AgwgAiAANgIIIAJBAjYCFCACQYiW
wAA2AhAgAkIBNwIcIAIgAkEIaq1CgICAgLABhDcDKCACIAJBKGo2AhggAkEQahBdIAJBMGokAAtf
AQF/AkAgA0EASA0AAkAgA0UEQEEBIQEMAQtBASEEIANBARDAASIBRQ0BCyADBEAgASACIAP8CgAA
CyAAIAM2AgggACABNgIEIAAgAzYCAA8LIAQgA0HkrsAAELMBAAtbAQF/IAEoAgAiBEEBcQRAIAAg
ASAEIARBfnEgAiADEGsPCyAEIAQoAggiAUEBajYCCCABQQBOBEAgACAENgIMIAAgAzYCCCAAIAI2
AgQgAEGMsMAANgIADwsAC1gBAX8gASgCACIEQQFxBEAgACABIAQgBCACIAMQaw8LIAQgBCgCCCIB
QQFqNgIIIAFBAE4EQCAAIAQ2AgwgACADNgIIIAAgAjYCBCAAQYywwAA2AgAPCwALWAEBfyMAQSBr
IgMkACADQRhqIAJBGGopAAA3AwAgA0EQaiACQRBqKQAANwMAIANBCGogAkEIaikAADcDACADIAIp
AAA3AwAgACADIAFBIBAyIANBIGokAAtOACMAQSBrIgAkACAAQQE2AgQgAEHctMAANgIAIABCATcC
DCAAQsS0wIDABzcDGCAAIABBGGo2AgggASgCACABKAIEIAAQOyAAQSBqJAALSwAgASgCACIBQQFx
BEAgAUF+cSEBIAMEQCABIAIgA/wKAAALIAAgAzYCCCAAIAE2AgQgACACIAFrIANqNgIADwsgACAB
IAIgAxBXC0gCAX8CfiMAQSBrIgIkACACIAApAwAiAyADQj+HIgSFIAR9IAJBDGoQSyABIANCAFlB
AUEAIAIoAgAgAigCBBAzIAJBIGokAAtLAQF/IAAoAgAgACgCCCIDayACSQRAIAAgAyACQQFBARBT
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
QRxqIBUpAwA3AgAgBUEkaiAWKQMANwIAIAVBLGogFygCADYCACABIA9BAWo2AhQLIAIgGGoiAiAI
Rw0ACwsgDiABKQIMNwIAIA5BCGogAUEUaigCADYCACABQYABaiQADAELIAIgCEHcmsAAENABAAsC
QAJAAkAgAygCGCICRQRAQQQhBAwBCyACQRRsIgFBBBDAASIERQ0BCyADQQA2AiQgAyAENgIgIAMg
AjYCHCADKAIUIgUgAkEwbGohCCADKAIQIQwgBSEBAkAgAgRAIANBNGohDiADQThqIQkgA0EoakEE
ciIEQQhqIQ8gBEEYaiEQIARBIGohESAEQShqIRIgASECA0AgAigCACIBBEAgAyABNgIoIAQgAkEE
aikCADcCACAPIAJBDGopAgA3AgAgBEEQaiACQRRqKQIANwIAIBAgAkEcaikCADcCACARIAJBJGop
AgA3AgAgEiACQSxqKAIANgIAIAYtADAhASAJEH0hCyADQdgAaiAJEGkgAyALIAFBAXNyOgBoIAMg
AygCMCIBNgJkIA4gAygCLCABIAMoAigoAhARAwAgAygCJCIBIAMoAhxGBEAgA0EcakHgksAAEGEL
IAMoAiAgAUEUbGoiCyADKQJYNwIAIAtBCGogA0HgAGopAgA3AgAgC0EQaiADQegAaigCADYCACAD
IAFBAWo2AiQgBkEBOgAwIAJBMGoiAiAIRw0BDAMLCyACQTBqIQELIAEgCEYNACAIIAFrIgJBMG4i
BkEBcUEAIQQgAkEwa0EwTwRAIAZB/v//P3EhBiABIQIDQCACQQxqIAJBBGooAgAgAkEIaigCACAC
KAIAKAIQEQMAIAJBPGogAkE0aigCACACQThqKAIAIAJBMGooAgAoAhARAwAgAkHgAGohAiAGIARB
AmoiBEcNAAsLRQ0AIAEgBEEwbGoiAUEMaiABKAIEIAEoAgggASgCACgCEBEDAAsgDARAIAUgDEEw
bBDMAQsgA0EANgJsIAMoAiAhAkEBIQYgA0HYAGogA0HsAGogAygCJCIBELIBAkAgAygCWEUEQCAD
KAJcIQEMAQsgA0H4AGogA0HgAGooAgA2AgAgAyADKQJYNwNwAkAgAQRAIAFBFGwhBiADQfAAakEE
ciEFIAMoAnghBANAIANBCGogAiADKAJwEFogAygCDCEBIAMoAghBAXENAiAFIAQgARDOASADIARB
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
AUEBNgIUIANBAToAMEEBCyEDIAFBADYCjAFBASEJIAFBGGogAUGMAWogAxCyAQJAIAEoAhhFBEAg
ASgCHCEEDAELIAFBgAFqIAFBIGooAgA2AgAgASABKQIYNwN4AkAgBARAIANBFGwhByABQfgAakEE
ciEKIAEoAoABIQMDQCABIAIgASgCeBBaIAEoAgQhBCABKAIAQQFxDQIgCiADIAQQzgEgASADQQFq
IgM2AoABIAJBFGohAiAHQRRrIgcNAAsLQQAhCSABKAJ8IQQMAQsgASgCfCIDQYQBSQ0AIAMQaAsg
ASgCFCIDBEAgASgCECECA0AgAigCACIHBEAgAkEEaigCACAHEMwBCyACQRRqIQIgA0EBayIDDQAL
CyABKAIMIgMEQCABKAIQIANBFGwQzAELIAsgBDYCBCALIAk2AgAgAUGQAWokACAFKAIMIQMgBSgC
CCEBIABBADYCACAIIAgoAgBBAWsiADYCACAARQRAIAVBHGoQjgELIAYgAUEBcSIANgIIIAYgA0EA
IAAbNgIEIAZBACADIAAbNgIAIAVBIGokAAwDCxDeAQsACxDfAQALIAYoAgAgBigCBCAGKAIIIAZB
EGokAAshAAJAIAEgAxC0AQRAIAAgASADIAIQuQEiAA0BCwALIAALJQAgAEUEQEGkrsAAQTIQ4AEA
CyAAIAIgAyAEIAUgASgCEBESAAsgAQF/QQEhASAAKAIAIgBBAXEEfyABBSAAKAIIQQFGCwsjACAA
RQRAQaSuwABBMhDgAQALIAAgAiADIAQgASgCEBEEAAsjACAARQRAQaSuwABBMhDgAQALIAAgAiAD
IAQgASgCEBEpAAsjACAARQRAQaSuwABBMhDgAQALIAAgAiADIAQgASgCEBErAAsjACAARQRAQaSu
wABBMhDgAQALIAAgAiADIAQgASgCEBETAAsjACAARQRAQaSuwABBMhDgAQALIAAgAiADIAQgASgC
EBEtAAsmAQF/IAAoAgAiAUGAgICAeHJBgICAgHhHBEAgACgCBCABEMwBCwshACAARQRAQaSuwABB
MhDgAQALIAAgAiADIAEoAhARAwALIgAgAC0AAEUEQCABQarewABBBRA4DwsgAUGv3sAAQQQQOAsf
ACAARQRAQaSuwABBMhDgAQALIAAgAiABKAIQEQAACyEAIABBADYCDCAAIAM2AgggACACNgIEIABB
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
KAIAKAIIQQFGC2sBAX8jAEEwayIDJAAgAyABNgIEIAMgADYCACADQQI2AgwgA0GM7sAANgIIIANC
AjcCFCADIANBBGqtQoCAgICgCYQ3AyggAyADrUKAgICAoAmENwMgIAMgA0EgajYCECADQQhqIAIQ
oAEAC2sBAX8jAEEwayIDJAAgAyABNgIEIAMgADYCACADQQI2AgwgA0Gs7sAANgIIIANCAjcCFCAD
IANBBGqtQoCAgICgCYQ3AyggAyADrUKAgICAoAmENwMgIAMgA0EgajYCECADQQhqIAIQoAEAC2sB
AX8jAEEwayIDJAAgAyABNgIEIAMgADYCACADQQI2AgwgA0Hg7sAANgIIIANCAjcCFCADIANBBGqt
QoCAgICgCYQ3AyggAyADrUKAgICAoAmENwMgIAMgA0EgajYCECADQQhqIAIQoAEACw8AQfzZwABB
KyAAEJIBAAucAgIBfgJ/IAAoAgApAwAhAiMAQZABayIDJAACfwJAIAEoAggiAEGAgIAQcUUEQCAA
QYCAgCBxDQEgA0EIaiACIANBEGoQSyABQQFBAUEAIAMoAgggAygCDBAzDAILQQAhAANAIAAgA2pB
jwFqIAKnQQ9xIgRBMHIgBEHXAGogBEEKSRs6AAAgAEEBayEAIAJCD1YgAkIEiCECDQALIAFBAUGg
3MAAQQIgACADakGQAWpBACAAaxAzDAELQQAhAANAIAAgA2pBjwFqIAKnQQ9xIgRBMHIgBEE3aiAE
QQpJGzoAACAAQQFrIQAgAkIPViACQgSIIQINAAsgAUEBQaDcwABBAiAAIANqQZABakEAIABrEDML
IANBkAFqJAALDgAgAUG0kcAAQQUQvAELDgAgAUHwkcAAQRAQvAELDgAgAUGklcAAQQUQvAELDgAg
AUGwl8AAQQoQvAELDAAgACgCACABEI8BC7ACAQF/IAAoAgAhAiMAQZABayIAJAAgACACKQMANwNQ
IAAgAikDCDcDWCAAIAIpAxA3A2AgACACKQMYNwNoIABBBDYCTCAAQYCxwAA2AkggAEEENgI8IABB
4LDAADYCOCAAIABB6ABqrUKAgICAoAeENwOIASAAIABB4ABqrUKAgICAoAeENwOAASAAIABB2ABq
rUKAgICAoAeENwN4IAAgAEHQAGqtQoCAgICgB4Q3A3AgAEEENgJEIAAgAEHwAGo2AkAgAEEsaiIC
IABBOGoQQyAAIAKtQoCAgICwB4Q3AyAgAEEBNgIMIABB0LLAADYCCCAAQgE3AhQgACAAQSBqNgIQ
IAEoAgAgASgCBCAAQQhqEDsgACgCLCICBEAgACgCMCACEMwBCyAAQZABaiQACw0AIABB3JfAACAB
EDsLDgAgAUHWrsAAQQsQvAELDQAgAEGgtcAAIAEQOwsNAEGguMAAQRsQ4AEACw4AQbu4wABBzwAQ
4AEACwkAIAAgARAkAAsNACAAQaC6wAAgARA7CwwAIAAgASkCADcDAAsNACAAQZC9wAAgARA7Cw4A
IAFBiL3AAEEFELwBCxoAIAAgAUH08cAAKAIAIgBBywAgABsRAgAACw0AIAFB5NnAAEEYEDgLCgAg
AiAAIAEQOAsKACAAIAElARACCw4AIAFBwrfAAEEDELwBCw4AIAFBuLXAAEEIELwBCwkAIABBADYC
AAsIACAAJQEQAwsIACAAJQEQEQsIACAAJQEQIQsEAEEACwIACwvTcBMAQYCAwAAL2RAvaG9tZS9u
b2RlLy5jYXJnby9yZWdpc3RyeS9zcmMvaW5kZXguY3JhdGVzLmlvLTE5NDljZjhjNmI1YjU1N2Yv
bGF6eV9zdGF0aWMtMS41LjAvc3JjL2lubGluZV9sYXp5LnJzAGxpYnJhcnkvY29yZS9zcmMvbnVt
L2ZsdDJkZWMvc3RyYXRlZ3kvZ3Jpc3UucnMAbGlicmFyeS9hbGxvYy9zcmMvZm10LnJzAGxpYnJh
cnkvY29yZS9zcmMvbnVtL2RpeV9mbG9hdC5ycwAvaG9tZS9ub2RlLy5jYXJnby9yZWdpc3RyeS9z
cmMvaW5kZXguY3JhdGVzLmlvLTE5NDljZjhjNmI1YjU1N2Yvd2FzbS1iaW5kZ2VuLTAuMi4xMDAv
c3JjL2NvbnZlcnQvaW1wbHMucnMAL2hvbWUvbm9kZS8uY2FyZ28vcmVnaXN0cnkvc3JjL2luZGV4
LmNyYXRlcy5pby0xOTQ5Y2Y4YzZiNWI1NTdmL3NlcmRlLTEuMC4yMTkvc3JjL2RlL2ltcGxzLnJz
AC9ob21lL25vZGUvLmNhcmdvL3JlZ2lzdHJ5L3NyYy9pbmRleC5jcmF0ZXMuaW8tMTk0OWNmOGM2
YjViNTU3Zi9ieXRlcy0xLjEwLjEvc3JjL2J5dGVzLnJzAC93b3Jrc3BhY2VzL2h1Z2dpbmdmYWNl
LmpzL3BhY2thZ2VzL2h1Yi94ZXQtY29yZS13YXNtLWJ1aWxkL21lcmtsZWhhc2gvc3JjL2FnZ3Jl
Z2F0ZWRfaGFzaGVzLnJzAC9ob21lL25vZGUvLmNhcmdvL3JlZ2lzdHJ5L3NyYy9pbmRleC5jcmF0
ZXMuaW8tMTk0OWNmOGM2YjViNTU3Zi93YXNtLWJpbmRnZW4tMC4yLjEwMC9zcmMvY29udmVydC9z
bGljZXMucnMAL3J1c3RjLzI5NDgzODgzZWVkNjlkNWZiNGRiMDE5NjRjZGYyYWY0ZDg2ZTljYjIv
bGlicmFyeS9jb3JlL3NyYy9pdGVyL3RyYWl0cy9pdGVyYXRvci5ycwBsaWJyYXJ5L2NvcmUvc3Jj
L251bS9mbHQyZGVjL3N0cmF0ZWd5L2RyYWdvbi5ycwBsaWJyYXJ5L2NvcmUvc3JjL251bS9iaWdu
dW0ucnMAL3dvcmtzcGFjZXMvaHVnZ2luZ2ZhY2UuanMvcGFja2FnZXMvaHViL3hldC1jb3JlLXdh
c20tYnVpbGQvbWVya2xlaGFzaC9zcmMvZGF0YV9oYXNoLnJzAC9ydXN0Yy8yOTQ4Mzg4M2VlZDY5
ZDVmYjRkYjAxOTY0Y2RmMmFmNGQ4NmU5Y2IyL2xpYnJhcnkvYWxsb2Mvc3JjL3N0cmluZy5ycwAv
d29ya3NwYWNlcy9odWdnaW5nZmFjZS5qcy9wYWNrYWdlcy9odWIveGV0LWNvcmUtd2FzbS1idWls
ZC9kZWR1cGxpY2F0aW9uL3NyYy9jaHVua2luZy5ycwBsaWJyYXJ5L2NvcmUvc3JjL3VuaWNvZGUv
cHJpbnRhYmxlLnJzAC9ydXN0Yy8yOTQ4Mzg4M2VlZDY5ZDVmYjRkYjAxOTY0Y2RmMmFmNGQ4NmU5
Y2IyL2xpYnJhcnkvc3RkL3NyYy9zeW5jL3BvaXNvbi9vbmNlLnJzAC9ydXN0Yy8yOTQ4Mzg4M2Vl
ZDY5ZDVmYjRkYjAxOTY0Y2RmMmFmNGQ4NmU5Y2IyL2xpYnJhcnkvYWxsb2Mvc3JjL3NsaWNlLnJz
AC9ydXN0L2RlcHMvaGFzaGJyb3duLTAuMTUuNC9zcmMvcmF3L21vZC5ycwBsaWJyYXJ5L2NvcmUv
c3JjL2ZtdC9tb2QucnMAbGlicmFyeS9jb3JlL3NyYy9zdHIvbW9kLnJzAC9ydXN0Yy8yOTQ4Mzg4
M2VlZDY5ZDVmYjRkYjAxOTY0Y2RmMmFmNGQ4NmU5Y2IyL2xpYnJhcnkvYWxsb2Mvc3JjL3Jhd192
ZWMvbW9kLnJzAGxpYnJhcnkvY29yZS9zcmMvbnVtL2ZsdDJkZWMvbW9kLnJzAC9ydXN0Yy8yOTQ4
Mzg4M2VlZDY5ZDVmYjRkYjAxOTY0Y2RmMmFmNGQ4NmU5Y2IyL2xpYnJhcnkvYWxsb2Mvc3JjL3Zl
Yy9zcGVjX2Zyb21faXRlcl9uZXN0ZWQucnMAL3J1c3QvZGVwcy9kbG1hbGxvYy0wLjIuOS9zcmMv
ZGxtYWxsb2MucnMAbGlicmFyeS9zdGQvc3JjL2FsbG9jLnJzAC9ob21lL25vZGUvLmNhcmdvL3Jl
Z2lzdHJ5L3NyYy9pbmRleC5jcmF0ZXMuaW8tMTk0OWNmOGM2YjViNTU3Zi9qcy1zeXMtMC4zLjc3
L3NyYy9saWIucnMAL2hvbWUvbm9kZS8uY2FyZ28vcmVnaXN0cnkvc3JjL2luZGV4LmNyYXRlcy5p
by0xOTQ5Y2Y4YzZiNWI1NTdmL3NlcmRlLXdhc20tYmluZGdlbi0wLjYuNS9zcmMvbGliLnJzAC9o
b21lL25vZGUvLmNhcmdvL3JlZ2lzdHJ5L3NyYy9pbmRleC5jcmF0ZXMuaW8tMTk0OWNmOGM2YjVi
NTU3Zi9vbmNlX2NlbGwtMS4yMS4zL3NyYy9saWIucnMAL2hvbWUvbm9kZS8uY2FyZ28vcmVnaXN0
cnkvc3JjL2luZGV4LmNyYXRlcy5pby0xOTQ5Y2Y4YzZiNWI1NTdmL2JsYWtlMy0xLjguMi9zcmMv
bGliLnJzAAAA8QEQAGAAAABZAAAAOAAAAPEBEABgAAAAWQAAAA8AAADxARAAYAAAAFYAAAA5AAAA
BAAAAAwAAAAEAAAABQAAAAYAAAAHAEHkkMAAC6kCAQAAAAgAAABhIERpc3BsYXkgaW1wbGVtZW50
YXRpb24gcmV0dXJuZWQgYW4gZXJyb3IgdW5leHBlY3RlZGx5ALwDEABMAAAADgsAAA4AAABFcnJv
cgAAANwEEABLAAAAwQEAAB0AAABKc0NodW5rSW5oYXNobGVuZ3RoANUIEAAEAAAA2QgQAAYAAABz
dHJ1Y3QgSnNDaHVua0luSnNDaHVua091dGRlZHVwYXR0ZW1wdGVkIHRvIHRha2Ugb3duZXJzaGlw
IG9mIFJ1c3QgdmFsdWUgd2hpbGUgaXQgd2FzIGJvcnJvd2VkAAAHCBAACwAAAD0AAAA4AAAABwgQ
AAsAAABBAAAAIQAAAAcIEAALAAAATAAAABQAAABRAhAAawAAACQBAAAOAEGwk8AAC1VJbnZhbGlk
IGhhc2ggaGV4OiAAALAJEAASAAAASW52YWxpZCBITUFDIGtleSBoZXg6IAAAzAkQABYAAAAgOiAK
AQAAAAAAAADsCRAAAwAAAO8JEAABAEGQlMAAC1EBAAAADAAAAGNhbGxlZCBgUmVzdWx0Ojp1bndy
YXAoKWAgb24gYW4gYEVycmAgdmFsdWUA8QEQAGAAAAA9AAAAKgAAAPEBEABgAAAAOAAAAB4AQeyU
wAALBQEAAAANAEH8lMAACwUBAAAADgBBjJXAAAsFAQAAAA8AQZyVwAALxwMBAAAAEAAAAEVycm9y
aW52YWxpZCB2YWx1ZTogLCBleHBlY3RlZCAAqQoQAA8AAAC4ChAACwAAAG1pc3NpbmcgZmllbGQg
YGDUChAADwAAAOMKEAABAAAAZHVwbGljYXRlIGZpZWxkIGAAAAD0ChAAEQAAAOMKEAABAAAAEQAA
AAwAAAAEAAAAEgAAABMAAAAHAAAAY2FsbGVkIGBPcHRpb246OnVud3JhcF90aHJvdygpYCBvbiBh
IGBOb25lYCB2YWx1ZQAAANwEEABLAAAAwQEAAB0AAABoYXNobGVuZ3RoAACKBRAAUQAAAC4CAAAR
AAAAvAMQAEwAAADoAQAAFwAAALwCEABZAAAA6wcAAAkAAABhIHNlcXVlbmNlAAA5ARAAXgAAAJUE
AAAiAAAAOQEQAF4AAACYBAAAHAAAABQAAAAMAAAABAAAABUAAAAWAAAABwAAAP8FEABfAAAAEwAA
AAUAAABpbnZhbGlkIHR5cGU6ICwgZXhwZWN0ZWQgAAAABAwQAA4AAAASDBAACwAAANwEEABLAAAA
wQEAAB0AAAABAAAAAAAAAPoGEABkAAAANQAAAA4AAAD//////////1gMEABB8JjAAAu9FgEAAABh
c3NlcnRpb24gZmFpbGVkOiB0YXJnZXRfY2h1bmtfc2l6ZSA+IDY0CAQQAFoAAAAiAAAACQAAAAgE
EABaAAAALgAAAB0AAABhc3NlcnRpb24gZmFpbGVkOiBtYXhpbXVtX2NodW5rID4gbWluaW11bV9j
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
GxAACwAAANMaEAABAAAAc3RyaW5nIAA8GxAABwAAAHVuaXQgdmFsdWVPcHRpb24gdmFsdWVuZXd0
eXBlIHN0cnVjdHNlcXVlbmNlbWFwZW51bXVuaXQgdmFyaWFudG5ld3R5cGUgdmFyaWFudHR1cGxl
IHZhcmlhbnRzdHJ1Y3QgdmFyaWFudAAAAAEAAAAAAAAALjB1MzIAAADPABAAagAAAGECAAAWAAAA
zwAQAGoAAABxAgAADAAAAM8AEABqAAAAbQIAABAAAABhcnJheSBjb250YWlucyBhIHZhbHVlIG9m
IHRoZSB3cm9uZyB0eXBlbnVsbCBwb2ludGVyIHBhc3NlZCB0byBydXN0cmVjdXJzaXZlIHVzZSBv
ZiBhbiBvYmplY3QgZGV0ZWN0ZWQgd2hpY2ggd291bGQgbGVhZCB0byB1bnNhZmUgYWxpYXNpbmcg
aW4gcnVzdExhenkgaW5zdGFuY2UgaGFzIHByZXZpb3VzbHkgYmVlbiBwb2lzb25lZIocEAAqAAAA
XgcQAFwAAAAIAwAAGQAAAHJlZW50cmFudCBpbml0AADMHBAADgAAAF4HEABcAAAAegIAAA0AAABK
c1ZhbHVlKCkAAAD0HBAACAAAAPwcEAABAAAAigUQAFEAAAAuAgAAEQAAAEwAAAAMAAAABAAAAE0A
AABOAAAATwAAAGFzc2VydGlvbiBmYWlsZWQ6IHBzaXplID49IHNpemUgKyBtaW5fb3ZlcmhlYWQA
AF4GEAAqAAAAsAQAAAkAAABhc3NlcnRpb24gZmFpbGVkOiBwc2l6ZSA8PSBzaXplICsgbWF4X292
ZXJoZWFkAABeBhAAKgAAALYEAAANAAAAbWVtb3J5IGFsbG9jYXRpb24gb2YgIGJ5dGVzIGZhaWxl
ZAAAuB0QABUAAADNHRAADQAAAIgGEAAZAAAAZAEAAAkAAABMAAAADAAAAAQAAABQAAAAAAAAAAgA
AAAEAAAAUQAAAAAAAAAIAAAABAAAAFIAAABTAAAAVAAAAFUAAABWAAAAEAAAAAQAAABXAAAAWAAA
AFkAAABaAAAASGFzaCB0YWJsZSBjYXBhY2l0eSBvdmVyZmxvd1QeEAAcAAAAJwUQACsAAAAlAAAA
KAAAAEVycm9yAAAAWwAAAAwAAAAEAAAAXAAAAF0AAABeAAAAY2FwYWNpdHkgb3ZlcmZsb3cAAACo
HhAAEQAAALoFEAAhAAAALgIAABEAAADsAxAAHAAAAOgBAAAXAEHsvcAAC6ARAQAAAF8AAABhIGZv
cm1hdHRpbmcgdHJhaXQgaW1wbGVtZW50YXRpb24gcmV0dXJuZWQgYW4gZXJyb3Igd2hlbiB0aGUg
dW5kZXJseWluZyBzdHJlYW0gZGlkIG5vdAAAlAAQABkAAACKAgAADgAAAABwAAcALQEBAQIBAgEB
SAswFRABZQcCBgICAQQjAR4bWws6CQkBGAQBCQEDAQUrAzsJKhgBIDcBAQEECAQBAwcKAh0BOgEB
AQIECAEJAQoCGgECAjkBBAIEAgIDAwEeAgMBCwI5AQQFAQIEARQCFgYBAToBAQIBBAgBBwMKAh4B
OwEBAQwBCQEoAQMBNwEBAwUDAQQHAgsCHQE6AQICAQEDAwEEBwILAhwCOQIBAQIECAEJAQoCHQFI
AQQBAgMBAQgBUQECBwwIYgECCQsHSQIbAQEBAQE3DgEFAQIFCwEkCQFmBAEGAQICAhkCBAMQBA0B
AgIGAQ8BAAMABBwDHQIeAkACAQcIAQILCQEtAwEBdQIiAXYDBAIJAQYD2wICAToBAQcBAQEBAggG
CgIBMB8xBDAKBAMmCQwCIAQCBjgBAQIDAQEFOAgCApgDAQ0BBwQBBgEDAsZAAAHDIQADjQFgIAAG
aQIABAEKIAJQAgABAwEEARkCBQGXAhoSDQEmCBkLAQEsAzABAgQCAgIBJAFDBgICAgIMAQgBLwEz
AQEDAgIFAgEBKgIIAe4BAgEEAQABABAQEAACAAHiAZUFAAMBAgUEKAMEAaUCAARBBQACTwRGCzEE
ewE2DykBAgIKAzEEAgIHAT0DJAUBCD4BDAI0CQEBCAQCAV8DAgQGAQIBnQEDCBUCOQIBAQEBDAEJ
AQ4HAwVDAQIGAQECAQEDBAMBAQ4CVQgCAwEBFwFRAQIGAQECAQECAQLrAQIEBgIBAhsCVQgCAQEC
agEBAQIIZQEBAQIEAQUACQEC9QEKBAQBkAQCAgQBIAooBgIECAEJBgIDLg0BAgAHAQYBAVIWAgcB
AgECegYDAQECAQcBAUgCAwEBAQACCwI0BQUDFwEAAQYPAAwDAwAFOwcAAT8EUQELAgACAC4CFwAF
AwYICAIHHgSUAwA3BDIIAQ4BFgUBDwAHARECBwECAQVkAaAHAAE9BAAE/gIAB20HAGCA8AAArQAQ
ACIAAAAuAAAACQAAAMFv8oYjAAAAge+shVtBbS3uBAAAAR9qv2TtOG7tl6fa9Pk/6QNPGAABPpUu
CZnfA/04FQ8v5HQj7PXP0wjcBMTasM28GX8zpgMmH+lOAgAAAXwumFuH075yn9nYhy8VEsZQ3mtw
bkrPD9iV1W5xsiawZsatJDYVHVrTQjwOVP9jwHNVzBfv+WXyKLxV98fcgNztbvTO79xf91MFAGFz
c2VydGlvbiBmYWlsZWQ6IGQubWFudCA+IDAVAxAAMAAAAHYAAAAFAAAAYXNzZXJ0aW9uIGZhaWxl
ZDogZC5taW51cyA+IDAAAAAVAxAAMAAAAHcAAAAFAAAAYXNzZXJ0aW9uIGZhaWxlZDogZC5wbHVz
ID4gMBUDEAAwAAAAeAAAAAUAAABhc3NlcnRpb24gZmFpbGVkOiBidWYubGVuKCkgPj0gTUFYX1NJ
R19ESUdJVFMAAAAVAxAAMAAAAHsAAAAFAAAAFQMQADAAAADCAAAACQAAABUDEAAwAAAA+wAAAA0A
AAAVAxAAMAAAAAIBAAASAAAAYXNzZXJ0aW9uIGZhaWxlZDogZC5tYW50LmNoZWNrZWRfc3ViKGQu
bWludXMpLmlzX3NvbWUoKQAVAxAAMAAAAHoAAAAFAAAAYXNzZXJ0aW9uIGZhaWxlZDogZC5tYW50
LmNoZWNrZWRfYWRkKGQucGx1cykuaXNfc29tZSgpAAAVAxAAMAAAAHkAAAAFAAAAFQMQADAAAAAL
AQAABQAAABUDEAAwAAAADAEAAAUAAAAVAxAAMAAAAA0BAAAFAAAAFQMQADAAAAByAQAAJAAAABUD
EAAwAAAAdwEAAC8AAAAVAxAAMAAAAIQBAAASAAAAFQMQADAAAABmAQAADQAAABUDEAAwAAAATAEA
ACIAAAAVAxAAMAAAAA8BAAAFAAAAFQMQADAAAAAOAQAABQAAAN9FGj0DzxrmwfvM/gAAAADKxprH
F/5wq9z71P4AAAAAT9y8vvyxd//2+9z+AAAAAAzWa0HvkVa+Efzk/gAAAAA8/H+QrR/QjSz87P4A
AAAAg5pVMShcUdNG/PT+AAAAALXJpq2PrHGdYfz8/gAAAADLi+4jdyKc6nv8BP8AAAAAbVN4QJFJ
zK6W/Az/AAAAAFfOtl15EjyCsfwU/wAAAAA3VvtNNpQQwsv8HP8AAAAAT5hIOG/qlpDm/CT/AAAA
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
ZCBgT3B0aW9uOjp1bndyYXAoKWAgb24gYSBgTm9uZWAgdmFsdWVpbmRleCBvdXQgb2YgYm91bmRz
OiB0aGUgbGVuIGlzICBidXQgdGhlIGluZGV4IGlzIAAAACctEAAgAAAARy0QABIAAAAAAAAABAAA
AAQAAABmAAAAPT0hPW1hdGNoZXNhc3NlcnRpb24gYGxlZnQgIHJpZ2h0YCBmYWlsZWQKICBsZWZ0
OiAKIHJpZ2h0OiAAhy0QABAAAACXLRAAFwAAAK4tEAAJAAAAIHJpZ2h0YCBmYWlsZWQ6IAogIGxl
ZnQ6IAAAAIctEAAQAAAA0C0QABAAAADgLRAACQAAAK4tEAAJAAAAOiAAAAEAAAAAAAAADC4QAAIA
AAAweDAwMDEwMjAzMDQwNTA2MDcwODA5MTAxMTEyMTMxNDE1MTYxNzE4MTkyMDIxMjIyMzI0MjUy
NjI3MjgyOTMwMzEzMjMzMzQzNTM2MzczODM5NDA0MTQyNDM0NDQ1NDY0NzQ4NDk1MDUxNTI1MzU0
NTU1NjU3NTg1OTYwNjE2MjYzNjQ2NTY2Njc2ODY5NzA3MTcyNzM3NDc1NzY3Nzc4Nzk4MDgxODI4
Mzg0ODU4Njg3ODg4OTkwOTE5MjkzOTQ5NTk2OTc5ODk5MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMGZhbHNldHJ1ZQBSBRAAHAAA
AKwKAAAmAAAAUgUQABwAAAC1CgAAGgAAAFsuLi5dYmVnaW4gPD0gZW5kICggPD0gKSB3aGVuIHNs
aWNpbmcgYGBZLxAADgAAAGcvEAAEAAAAay8QABAAAAB7LxAAAQAAAGJ5dGUgaW5kZXggIGlzIG5v
dCBhIGNoYXIgYm91bmRhcnk7IGl0IGlzIGluc2lkZSAgKGJ5dGVzICkgb2YgYACcLxAACwAAAKcv
EAAmAAAAzS8QAAgAAADVLxAABgAAAHsvEAABAAAAIGlzIG91dCBvZiBib3VuZHMgb2YgYAAAnC8Q
AAsAAAAEMBAAFgAAAHsvEAABAAAAbgUQABwAAACfAQAALAAAAGIEEAAmAAAAGgAAADYAAABiBBAA
JgAAAAoAAAArAAAAAAYBAQMBBAIFBwcCCAgJAgoFCwIOBBABEQISBRMcFAEVAhcCGQ0cBR0IHwEk
AWoEawKvA7ECvALPAtEC1AzVCdYC1wLaAeAF4QLnBOgC7iDwBPgC+gT7AQwnOz5OT4+enp97i5OW
orK6hrEGBwk2PT5W89DRBBQYNjdWV3+qrq+9NeASh4mOngQNDhESKTE0OkVGSUpOT2RlioyNj7bB
w8TGy9ZctrcbHAcICgsUFzY5Oqip2NkJN5CRqAcKOz5maY+SEW9fv+7vWmL0/P9TVJqbLi8nKFWd
oKGjpKeorbq8xAYLDBUdOj9FUaanzM2gBxkaIiU+P+fs7//FxgQgIyUmKDM4OkhKTFBTVVZYWlxe
YGNlZmtzeH1/iqSqr7DA0K6vbm/d3pNeInsFAwQtA2YDAS8ugIIdAzEPHAQkCR4FKwVEBA4qgKoG
JAQkBCgINAtOAzQMgTcJFgoIGDtFOQNjCAkwFgUhAxsFAUA4BEsFLwQKBwkHQCAnBAwJNgM6BRoH
BAwHUEk3Mw0zBy4ICgYmAx0IAoDQUhADNywIKhYaJhwUFwlOBCQJRA0ZBwoGSAgnCXULQj4qBjsF
CgZRBgEFEAMFC1kIAh1iHkgICoCmXiJFCwoGDRM6BgoGFBwsBBeAuTxkUwxICQpGRRtICFMNSQcK
gLYiDgoGRgodA0dJNwMOCAoGOQcKgTYZBzsDHVUBDzINg5tmdQuAxIpMYw2EMBAWCo+bBYJHmrk6
hsaCOQcqBFwGJgpGCigFE4GwOoDGW2VLBDkHEUAFCwIOl/gIhNYpCqLngTMPAR0GDgQIgYyJBGsF
DQMJBxCPYID6BoG0TEcJdDyA9gpzCHAVRnoUDBQMVwkZgIeBRwOFQg8VhFAfBgaA1SsFPiEBcC0D
GgQCgUAfEToFAYHQKoDWKwQBgeCA9ylMBAoEAoMRREw9gMI8BgEEVQUbNAKBDiwEZAxWCoCuOB0N
LAQJBwIOBoCag9gEEQMNA3cEXwYMBAEPDAQ4CAoGKAgsBAI+gVQMHQMKBTgHHAYJB4D6hAYAAQMF
BQYGAgcGCAcJEQocCxkMGg0QDgwPBBADEhITCRYBFwQYARkDGgcbARwCHxYgAysDLQsuATAEMQIy
AacEqQKqBKsI+gL7Bf0C/gP/Ca14eYuNojBXWIuMkBzdDg9LTPv8Li8/XF1f4oSNjpGSqbG6u8XG
ycre5OX/AAQREikxNDc6Oz1JSl2EjpKpsbS6u8bKzs/k5QAEDQ4REikxNDo7RUZJSl5kZYSRm53J
zs8NESk6O0VJV1tcXl9kZY2RqbS6u8XJ3+Tl8A0RRUlkZYCEsry+v9XX8PGDhYukpr6/xcfP2ttI
mL3Nxs7PSU5PV1leX4mOj7G2t7/BxsfXERYXW1z29/7/gG1x3t8OH25vHB1ffX6ur027vBYXHh9G
R05PWFpcXn5/tcXU1dzw8fVyc490dZYmLi+nr7e/x8/X35oAQJeYMI8fzs/S1M7/Tk9aWwcIDxAn
L+7vbm83PT9CRZCRU2d1yMnQ0djZ5/7/ACBfIoLfBIJECBsEBhGBrA6AqwUfCIEcAxkIAQQvBDQE
BwMBBwYHEQpQDxIHVQcDBBwKCQMIAwcDAgMDAwwEBQMLBgEOFQVOBxsHVwcCBhcMUARDAy0DAQQR
Bg8MOgQdJV8gbQRqJYDIBYKwAxoGgv0DWQcWCRgJFAwUDGoGCgYaBlkHKwVGCiwEDAQBAzELLAQa
BgsDgKwGCgYvMYD0CDwDDwM+BTgIKwWC/xEYCC8RLQMhDyEPgIwEgpoWCxWIlAUvBTsHAg4YCYC+
InQMgNYagRAFgOEJ8p4DNwmBXBSAuAiA3RU7AwoGOAhGCAwGdAseA1oEWQmAgxgcChYJTASAigar
pAwXBDGhBIHaJgcMBQWAphCB9QcBICoGTASAjQSAvgMbAw8NAAAARQMQAB8AAACrAQAAAQAAAGFz
c2VydGlvbiBmYWlsZWQ6IG5vYm9ycm93YXNzZXJ0aW9uIGZhaWxlZDogZGlnaXRzIDwgNDBhc3Nl
cnRpb24gZmFpbGVkOiBvdGhlciA+IDBhdHRlbXB0IHRvIGRpdmlkZSBieSB6ZXJvAHI2EAAZAAAA
YXR0ZW1wdCB0byBjYWxjdWxhdGUgdGhlIHJlbWFpbmRlciB3aXRoIGEgZGl2aXNvciBvZiB6ZXJv
AAAAlDYQADkAAAByYW5nZSBzdGFydCBpbmRleCAgb3V0IG9mIHJhbmdlIGZvciBzbGljZSBvZiBs
ZW5ndGgg2DYQABIAAADqNhAAIgAAAHJhbmdlIGVuZCBpbmRleCAcNxAAEAAAAOo2EAAiAAAAc2xp
Y2UgaW5kZXggc3RhcnRzIGF0ICBidXQgZW5kcyBhdCAAPDcQABYAAABSNxAADQAAAGNvcHlfZnJv
bV9zbGljZTogc291cmNlIHNsaWNlIGxlbmd0aCAoKSBkb2VzIG5vdCBtYXRjaCBkZXN0aW5hdGlv
biBzbGljZSBsZW5ndGggKAAAAHA3EAAmAAAAljcQACsAAADILBAAAQAAAAADAACDBCAAkQVgAF0T
oAASFyAfDCBgH+8sICsqMKArb6ZgLAKo4Cwe++AtAP4gNp7/YDb9AeE2AQohNyQN4TerDmE5Lxjh
OTAc4UrzHuFOQDShUh5h4VPwamFUT2/hVJ28YVUAz2FWZdGhVgDaIVcA4KFYruIhWuzk4VvQ6GFc
IADuXPABf118LRAAfi0QAIAtEAACAAAAAgAAAAcAQZTxwAALAUgAcAlwcm9kdWNlcnMCCGxhbmd1
YWdlAQRSdXN0AAxwcm9jZXNzZWQtYnkDBXJ1c3RjHTEuODkuMCAoMjk0ODM4ODNlIDIwMjUtMDgt
MDQpBndhbHJ1cwYwLjIzLjMMd2FzbS1iaW5kZ2VuBzAuMi4xMDAAaw90YXJnZXRfZmVhdHVyZXMG
Kw9tdXRhYmxlLWdsb2JhbHMrE25vbnRyYXBwaW5nLWZwdG9pbnQrC2J1bGstbWVtb3J5KwhzaWdu
LWV4dCsPcmVmZXJlbmNlLXR5cGVzKwptdWx0aXZhbHVl
`.trim().replaceAll("\n", "")
    );
    wasmBinary = new Uint8Array(wasmBase64.length);
    for (let i = 0; i < wasmBase64.length; i++) {
      wasmBinary[i] = wasmBase64.charCodeAt(i);
    }
  }
});

// src/vendor/xet-chunk/chunker_wasm.ts
var chunker_wasm_exports = {};
__export(chunker_wasm_exports, {
  Chunker: () => Chunker,
  compute_file_hash: () => compute_file_hash,
  compute_hmac: () => compute_hmac,
  compute_verification_hash: () => compute_verification_hash,
  compute_xorb_hash: () => compute_xorb_hash,
  init: () => init
});
async function init() {
  if (initPromise) {
    return initPromise;
  }
  let resolve3;
  let reject;
  initPromise = new Promise((_resolve, _reject) => {
    resolve3 = _resolve;
    reject = _reject;
  });
  await Promise.resolve();
  try {
    const wasmModule2 = await WebAssembly.compile(wasmBinary);
    const imports = Object.entries(
      WebAssembly.Module.imports(wasmModule2).reduce(
        (result, item) => ({
          ...result,
          // @ts-expect-error ok for any type
          [item.module]: [...result[item.module] || [], item.name]
        }),
        {}
      )
    ).map(([from, names]) => ({ from, names }));
    const wasm2 = await WebAssembly.instantiate(wasmModule2, {
      "./hf_xet_thin_wasm_bg.js": Object.fromEntries(
        // @ts-expect-error ok for any type
        imports[0].names.map((name) => [name, chunker_wasm_bg_exports[name]])
      )
    });
    __wbg_set_wasm(wasm2.exports);
    wasm2.exports.__wbindgen_start();
    resolve3();
  } catch (error) {
    reject(error);
  }
}
var initPromise;
var init_chunker_wasm = __esm({
  "src/vendor/xet-chunk/chunker_wasm.ts"() {
    "use strict";
    init_chunker_wasm_bg();
    init_chunker_wasm_bg();
    init_chunker_wasm_bg_wasm_base64();
    init_chunker_wasm_bg();
    initPromise = null;
    init();
  }
});

// index.ts
var hub_exports = {};
__export(hub_exports, {
  DATASET_EXPANDABLE_KEYS: () => DATASET_EXPANDABLE_KEYS,
  DATASET_EXPAND_KEYS: () => DATASET_EXPAND_KEYS,
  DEFAULT_REVISION: () => DEFAULT_REVISION,
  HUB_URL: () => HUB_URL,
  HubApiError: () => HubApiError,
  InvalidApiResponseFormatError: () => InvalidApiResponseFormatError,
  MODEL_EXPANDABLE_KEYS: () => MODEL_EXPANDABLE_KEYS,
  MODEL_EXPAND_KEYS: () => MODEL_EXPAND_KEYS,
  REGEX_COMMIT_HASH: () => REGEX_COMMIT_HASH,
  REPO_ID_SEPARATOR: () => REPO_ID_SEPARATOR,
  RE_SAFETENSORS_FILE: () => RE_SAFETENSORS_FILE,
  RE_SAFETENSORS_INDEX_FILE: () => RE_SAFETENSORS_INDEX_FILE,
  RE_SAFETENSORS_SHARD_FILE: () => RE_SAFETENSORS_SHARD_FILE,
  SAFETENSORS_FILE: () => SAFETENSORS_FILE,
  SAFETENSORS_INDEX_FILE: () => SAFETENSORS_INDEX_FILE,
  SPACE_EXPANDABLE_KEYS: () => SPACE_EXPANDABLE_KEYS,
  SPACE_EXPAND_KEYS: () => SPACE_EXPAND_KEYS,
  __internal_XetBlob: () => XetBlob,
  __internal_sha256: () => sha256,
  checkRepoAccess: () => checkRepoAccess,
  commit: () => commit,
  commitIter: () => commitIter,
  countCommits: () => countCommits,
  createBranch: () => createBranch,
  createCollection: () => createCollection,
  createRepo: () => createRepo,
  datasetInfo: () => datasetInfo,
  deleteBranch: () => deleteBranch,
  deleteCollection: () => deleteCollection,
  deleteFile: () => deleteFile,
  deleteFiles: () => deleteFiles,
  deleteRepo: () => deleteRepo,
  downloadFile: () => downloadFile,
  downloadFileToCacheDir: () => downloadFileToCacheDir,
  fileDownloadInfo: () => fileDownloadInfo,
  fileExists: () => fileExists,
  getBlobStat: () => getBlobStat,
  getHFHubCachePath: () => getHFHubCachePath,
  getRepoFolderName: () => getRepoFolderName,
  listCollections: () => listCollections,
  listCommits: () => listCommits,
  listDatasets: () => listDatasets,
  listFiles: () => listFiles,
  listModels: () => listModels,
  listSpaces: () => listSpaces,
  modelInfo: () => modelInfo,
  oauthHandleRedirect: () => oauthHandleRedirect,
  oauthHandleRedirectIfPresent: () => oauthHandleRedirectIfPresent,
  oauthLoginUrl: () => oauthLoginUrl,
  parseRepoType: () => parseRepoType,
  parseSafetensorsMetadata: () => parseSafetensorsMetadata,
  parseSafetensorsShardFilename: () => parseSafetensorsShardFilename,
  pathsInfo: () => pathsInfo,
  repoExists: () => repoExists,
  scanCacheDir: () => scanCacheDir,
  scanCachedRepo: () => scanCachedRepo,
  scanRefsDir: () => scanRefsDir,
  scanSnapshotDir: () => scanSnapshotDir,
  snapshotDownload: () => snapshotDownload,
  spaceInfo: () => spaceInfo,
  uploadFile: () => uploadFile,
  uploadFiles: () => uploadFiles,
  uploadFilesWithProgress: () => uploadFilesWithProgress,
  whoAmI: () => whoAmI
});
module.exports = __toCommonJS(hub_exports);

// src/lib/cache-management.ts
var import_node_os = require("os");
var import_node_path = require("path");
var import_promises = require("fs/promises");
function getDefaultHome() {
  return (0, import_node_path.join)((0, import_node_os.homedir)(), ".cache");
}
function getDefaultCachePath() {
  return (0, import_node_path.join)(process.env["HF_HOME"] ?? (0, import_node_path.join)(process.env["XDG_CACHE_HOME"] ?? getDefaultHome(), "huggingface"), "hub");
}
function getHuggingFaceHubCache() {
  return process.env["HUGGINGFACE_HUB_CACHE"] ?? getDefaultCachePath();
}
function getHFHubCachePath() {
  return process.env["HF_HUB_CACHE"] ?? getHuggingFaceHubCache();
}
var FILES_TO_IGNORE = [".DS_Store"];
var REPO_ID_SEPARATOR = "--";
function getRepoFolderName({ name, type }) {
  const parts = [`${type}s`, ...name.split("/")];
  return parts.join(REPO_ID_SEPARATOR);
}
async function scanCacheDir(cacheDir = void 0) {
  if (!cacheDir)
    cacheDir = getHFHubCachePath();
  const s = await (0, import_promises.stat)(cacheDir);
  if (!s.isDirectory()) {
    throw new Error(
      `Scan cache expects a directory but found a file: ${cacheDir}. Please use \`cacheDir\` argument or set \`HF_HUB_CACHE\` environment variable.`
    );
  }
  const repos = [];
  const warnings = [];
  const directories = await (0, import_promises.readdir)(cacheDir);
  for (const repo of directories) {
    if (repo === ".locks")
      continue;
    const absolute = (0, import_node_path.join)(cacheDir, repo);
    const s2 = await (0, import_promises.stat)(absolute);
    if (!s2.isDirectory()) {
      continue;
    }
    try {
      const cached = await scanCachedRepo(absolute);
      repos.push(cached);
    } catch (err) {
      warnings.push(err);
    }
  }
  return {
    repos,
    size: [...repos.values()].reduce((sum2, repo) => sum2 + repo.size, 0),
    warnings
  };
}
async function scanCachedRepo(repoPath) {
  const name = (0, import_node_path.basename)(repoPath);
  if (!name.includes(REPO_ID_SEPARATOR)) {
    throw new Error(`Repo path is not a valid HuggingFace cache directory: ${name}`);
  }
  const [type, ...remaining] = name.split(REPO_ID_SEPARATOR);
  const repoType = parseRepoType(type);
  const repoId = remaining.join("/");
  const snapshotsPath = (0, import_node_path.join)(repoPath, "snapshots");
  const refsPath = (0, import_node_path.join)(repoPath, "refs");
  const snapshotStat = await (0, import_promises.stat)(snapshotsPath);
  if (!snapshotStat.isDirectory()) {
    throw new Error(`Snapshots dir doesn't exist in cached repo ${snapshotsPath}`);
  }
  const refsByHash = /* @__PURE__ */ new Map();
  const refsStat = await (0, import_promises.stat)(refsPath);
  if (refsStat.isDirectory()) {
    await scanRefsDir(refsPath, refsByHash);
  }
  const cachedRevisions = [];
  const blobStats = /* @__PURE__ */ new Map();
  const snapshotDirs = await (0, import_promises.readdir)(snapshotsPath);
  for (const dir of snapshotDirs) {
    if (FILES_TO_IGNORE.includes(dir))
      continue;
    const revisionPath = (0, import_node_path.join)(snapshotsPath, dir);
    const revisionStat = await (0, import_promises.stat)(revisionPath);
    if (!revisionStat.isDirectory()) {
      throw new Error(`Snapshots folder corrupted. Found a file: ${revisionPath}`);
    }
    const cachedFiles = [];
    await scanSnapshotDir(revisionPath, cachedFiles, blobStats);
    const revisionLastModified = cachedFiles.length > 0 ? Math.max(...[...cachedFiles].map((file) => file.blob.lastModifiedAt.getTime())) : revisionStat.mtimeMs;
    cachedRevisions.push({
      commitOid: dir,
      files: cachedFiles,
      refs: refsByHash.get(dir) || [],
      size: [...cachedFiles].reduce((sum2, file) => sum2 + file.blob.size, 0),
      path: revisionPath,
      lastModifiedAt: new Date(revisionLastModified)
    });
    refsByHash.delete(dir);
  }
  if (refsByHash.size > 0) {
    throw new Error(
      `Reference(s) refer to missing commit hashes: ${JSON.stringify(Object.fromEntries(refsByHash))} (${repoPath})`
    );
  }
  const repoStats = await (0, import_promises.stat)(repoPath);
  const repoLastAccessed = blobStats.size > 0 ? Math.max(...[...blobStats.values()].map((stat5) => stat5.atimeMs)) : repoStats.atimeMs;
  const repoLastModified = blobStats.size > 0 ? Math.max(...[...blobStats.values()].map((stat5) => stat5.mtimeMs)) : repoStats.mtimeMs;
  return {
    id: {
      name: repoId,
      type: repoType
    },
    path: repoPath,
    filesCount: blobStats.size,
    revisions: cachedRevisions,
    size: [...blobStats.values()].reduce((sum2, stat5) => sum2 + stat5.size, 0),
    lastAccessedAt: new Date(repoLastAccessed),
    lastModifiedAt: new Date(repoLastModified)
  };
}
async function scanRefsDir(refsPath, refsByHash) {
  const refFiles = await (0, import_promises.readdir)(refsPath, { withFileTypes: true });
  for (const refFile of refFiles) {
    const refFilePath = (0, import_node_path.join)(refsPath, refFile.name);
    if (refFile.isDirectory())
      continue;
    const commitHash = await (0, import_promises.readFile)(refFilePath, "utf-8");
    const refName = refFile.name;
    if (!refsByHash.has(commitHash)) {
      refsByHash.set(commitHash, []);
    }
    refsByHash.get(commitHash)?.push(refName);
  }
}
async function scanSnapshotDir(revisionPath, cachedFiles, blobStats) {
  const files = await (0, import_promises.readdir)(revisionPath, { withFileTypes: true });
  for (const file of files) {
    if (file.isDirectory())
      continue;
    const filePath = (0, import_node_path.join)(revisionPath, file.name);
    const blobPath = await (0, import_promises.realpath)(filePath);
    const blobStat = await getBlobStat(blobPath, blobStats);
    cachedFiles.push({
      path: filePath,
      blob: {
        path: blobPath,
        size: blobStat.size,
        lastAccessedAt: new Date(blobStat.atimeMs),
        lastModifiedAt: new Date(blobStat.mtimeMs)
      }
    });
  }
}
async function getBlobStat(blobPath, blobStats) {
  const blob = blobStats.get(blobPath);
  if (!blob) {
    const statResult = await (0, import_promises.lstat)(blobPath);
    blobStats.set(blobPath, statResult);
    return statResult;
  }
  return blob;
}
function parseRepoType(type) {
  switch (type) {
    case "models":
      return "model";
    case "datasets":
      return "dataset";
    case "spaces":
      return "space";
    default:
      throw new TypeError(`Invalid repo type: ${type}`);
  }
}

// src/consts.ts
var HUB_URL = "https://huggingface.co";

// src/error.ts
async function createApiError(response, opts) {
  const error = new HubApiError(response.url, response.status, response.headers.get("X-Request-Id") ?? opts?.requestId);
  error.message = `Api error with status ${error.statusCode}${opts?.message ? `. ${opts.message}` : ""}`;
  const trailer = [`URL: ${error.url}`, error.requestId ? `Request ID: ${error.requestId}` : void 0].filter(Boolean).join(". ");
  if (response.headers.get("Content-Type")?.startsWith("application/json")) {
    const json = await response.json();
    error.message = json.error || json.message || error.message;
    if (json.error_description) {
      error.message = error.message ? error.message + `: ${json.error_description}` : json.error_description;
    }
    error.data = json;
  } else {
    error.data = { message: await response.text() };
  }
  error.message += `. ${trailer}`;
  throw error;
}
var HubApiError = class extends Error {
  statusCode;
  url;
  requestId;
  data;
  constructor(url, statusCode, requestId, message) {
    super(message);
    this.statusCode = statusCode;
    this.requestId = requestId;
    this.url = url;
  }
};
var InvalidApiResponseFormatError = class extends Error {
};

// src/utils/checkCredentials.ts
function checkAccessToken(accessToken) {
  if (!accessToken.startsWith("hf_")) {
    throw new TypeError("Your access token must start with 'hf_'");
  }
}
function checkCredentials(params) {
  if (params.accessToken) {
    checkAccessToken(params.accessToken);
    return params.accessToken;
  }
  if (params.credentials?.accessToken) {
    checkAccessToken(params.credentials.accessToken);
    return params.credentials.accessToken;
  }
}

// src/utils/toRepoId.ts
function toRepoId(repo) {
  if (typeof repo !== "string") {
    return repo;
  }
  if (repo.startsWith("model/") || repo.startsWith("models/")) {
    throw new TypeError(
      "A repo designation for a model should not start with 'models/', directly specify the model namespace / name"
    );
  }
  if (repo.startsWith("space/")) {
    throw new TypeError("Spaces should start with 'spaces/', plural, not 'space/'");
  }
  if (repo.startsWith("dataset/")) {
    throw new TypeError("Datasets should start with 'dataset/', plural, not 'dataset/'");
  }
  const slashes = repo.split("/").length - 1;
  if (repo.startsWith("spaces/")) {
    if (slashes !== 2) {
      throw new TypeError("Space Id must include namespace and name of the space");
    }
    return {
      type: "space",
      name: repo.slice("spaces/".length)
    };
  }
  if (repo.startsWith("datasets/")) {
    if (slashes > 2) {
      throw new TypeError("Too many slashes in repo designation: " + repo);
    }
    return {
      type: "dataset",
      name: repo.slice("datasets/".length)
    };
  }
  if (slashes > 1) {
    throw new TypeError("Too many slashes in repo designation: " + repo);
  }
  return {
    type: "model",
    name: repo
  };
}

// src/lib/check-repo-access.ts
async function checkRepoAccess(params) {
  const accessToken = params && checkCredentials(params);
  const repoId = toRepoId(params.repo);
  const response = await (params.fetch || fetch)(`${params?.hubUrl || HUB_URL}/api/${repoId.type}s/${repoId.name}`, {
    headers: {
      ...accessToken ? { Authorization: `Bearer ${accessToken}` } : {}
    }
  });
  if (!response.ok) {
    throw await createApiError(response);
  }
}

// src/utils/range.ts
function range(n, b) {
  return b ? Array(b - n).fill(0).map((_, i) => n + i) : Array(n).fill(0).map((_, i) => i);
}

// src/utils/chunk.ts
function chunk(arr, chunkSize) {
  if (isNaN(chunkSize) || chunkSize < 1) {
    throw new RangeError("Invalid chunk size: " + chunkSize);
  }
  if (!arr.length) {
    return [];
  }
  if (arr.length <= chunkSize) {
    return [arr];
  }
  return range(Math.ceil(arr.length / chunkSize)).map((i) => {
    return arr.slice(i * chunkSize, (i + 1) * chunkSize);
  });
}

// src/utils/promisesQueue.ts
async function promisesQueue(factories, concurrency) {
  const results = [];
  const executing = /* @__PURE__ */ new Set();
  let index = 0;
  for (const factory of factories) {
    const closureIndex = index++;
    const e = factory().then((r) => {
      results[closureIndex] = r;
      executing.delete(e);
    });
    executing.add(e);
    if (executing.size >= concurrency) {
      await Promise.race(executing);
    }
  }
  await Promise.all(executing);
  return results;
}

// src/utils/promisesQueueStreaming.ts
async function promisesQueueStreaming(factories, concurrency) {
  const executing = [];
  for await (const factory of factories) {
    const e = factory().then(() => {
      executing.splice(executing.indexOf(e), 1);
    });
    executing.push(e);
    if (executing.length >= concurrency) {
      await Promise.race(executing);
    }
  }
  await Promise.all(executing);
}

// src/utils/eventToGenerator.ts
async function* eventToGenerator(cb) {
  const promises = [];
  function addPromise() {
    let resolve3;
    let reject;
    const p = new Promise((res, rej) => {
      resolve3 = res;
      reject = rej;
    });
    promises.push({ p, resolve: resolve3, reject });
  }
  addPromise();
  const callbackRes = Promise.resolve().then(
    () => cb(
      (y) => {
        addPromise();
        promises.at(-2)?.resolve({ done: false, value: y });
      },
      (r) => {
        addPromise();
        promises.at(-2)?.resolve({ done: true, value: r });
      },
      (err) => promises.shift()?.reject(err)
    )
  ).catch((err) => promises.shift()?.reject(err));
  while (1) {
    const p = promises[0];
    if (!p) {
      throw new Error("Logic error in eventGenerator, promises should never be empty");
    }
    const result = await p.p;
    promises.shift();
    if (result.done) {
      await callbackRes;
      return result.value;
    }
    yield result.value;
  }
  throw new Error("Unreachable");
}

// src/utils/hexFromBytes.ts
function hexFromBytes(arr) {
  if (globalThis.Buffer) {
    return globalThis.Buffer.from(arr).toString("hex");
  } else {
    const bin = [];
    arr.forEach((byte) => {
      bin.push(byte.toString(16).padStart(2, "0"));
    });
    return bin.join("");
  }
}

// src/utils/isBackend.ts
var isBrowser = typeof window !== "undefined" && typeof window.document !== "undefined";
var isWebWorker = typeof self === "object" && self.constructor && self.constructor.name === "DedicatedWorkerGlobalScope";
var isBackend = !isBrowser && !isWebWorker;

// src/utils/isFrontend.ts
var isFrontend = !isBackend;

// src/utils/sha256.ts
async function getWebWorkerCode() {
  const sha256Module = await Promise.resolve().then(() => (init_sha256_wrapper(), sha256_wrapper_exports));
  return URL.createObjectURL(new Blob([sha256Module.createSHA256WorkerCode()]));
}
var pendingWorkers = [];
var runningWorkers = /* @__PURE__ */ new Set();
var resolve;
var waitPromise = new Promise((r) => {
  resolve = r;
});
async function getWorker(poolSize) {
  {
    const worker2 = pendingWorkers.pop();
    if (worker2) {
      runningWorkers.add(worker2);
      return worker2;
    }
  }
  if (!poolSize) {
    const worker2 = new Worker(await getWebWorkerCode());
    runningWorkers.add(worker2);
    return worker2;
  }
  if (poolSize <= 0) {
    throw new TypeError("Invalid webworker pool size: " + poolSize);
  }
  while (runningWorkers.size >= poolSize) {
    await waitPromise;
  }
  const worker = new Worker(await getWebWorkerCode());
  runningWorkers.add(worker);
  return worker;
}
async function freeWorker(worker, poolSize) {
  if (!poolSize) {
    return destroyWorker(worker);
  }
  runningWorkers.delete(worker);
  pendingWorkers.push(worker);
  const r = resolve;
  waitPromise = new Promise((r2) => {
    resolve = r2;
  });
  r();
}
function destroyWorker(worker) {
  runningWorkers.delete(worker);
  worker.terminate();
  const r = resolve;
  waitPromise = new Promise((r2) => {
    resolve = r2;
  });
  r();
}
async function* sha256(buffer, opts) {
  yield 0;
  const maxCryptoSize = typeof opts?.useWebWorker === "object" && opts?.useWebWorker.minSize !== void 0 ? opts.useWebWorker.minSize : 1e7;
  if (buffer.size < maxCryptoSize && globalThis.crypto?.subtle) {
    const res = hexFromBytes(
      new Uint8Array(
        await globalThis.crypto.subtle.digest("SHA-256", buffer instanceof Blob ? await buffer.arrayBuffer() : buffer)
      )
    );
    yield 1;
    return res;
  }
  if (isFrontend) {
    if (opts?.useWebWorker) {
      try {
        const poolSize = typeof opts?.useWebWorker === "object" ? opts.useWebWorker.poolSize : void 0;
        const worker = await getWorker(poolSize);
        let messageHandler;
        let errorHandler;
        const cleanup = () => {
          worker.removeEventListener("message", messageHandler);
          worker.removeEventListener("error", errorHandler);
        };
        return yield* eventToGenerator((yieldCallback, returnCallback, rejectCallback) => {
          messageHandler = (event) => {
            if (event.data.sha256) {
              cleanup();
              freeWorker(worker, poolSize);
              returnCallback(event.data.sha256);
            } else if (event.data.progress) {
              yieldCallback(event.data.progress);
              try {
                opts.abortSignal?.throwIfAborted();
              } catch (err) {
                cleanup();
                destroyWorker(worker);
                rejectCallback(err);
              }
            } else {
              cleanup();
              destroyWorker(worker);
              rejectCallback(event);
            }
          };
          errorHandler = (event) => {
            cleanup();
            destroyWorker(worker);
            rejectCallback(event.error);
          };
          if (opts?.abortSignal) {
            try {
              opts.abortSignal?.throwIfAborted();
            } catch (err) {
              cleanup();
              destroyWorker(worker);
              rejectCallback(opts.abortSignal.reason ?? new DOMException("Aborted", "AbortError"));
              return;
            }
            const abortListener = () => {
              cleanup();
              destroyWorker(worker);
              rejectCallback(opts.abortSignal?.reason ?? new DOMException("Aborted", "AbortError"));
              opts.abortSignal?.removeEventListener("abort", abortListener);
            };
            opts.abortSignal.addEventListener("abort", abortListener);
          }
          worker.addEventListener("message", messageHandler);
          worker.addEventListener("error", errorHandler);
          worker.postMessage({ file: buffer });
        });
      } catch (err) {
        console.warn("Failed to use web worker for sha256", err);
      }
    }
    if (!wasmModule) {
      wasmModule = await Promise.resolve().then(() => (init_sha256_wrapper(), sha256_wrapper_exports));
    }
    const sha2562 = await wasmModule.createSHA256();
    sha2562.init();
    const reader = buffer.stream().getReader();
    const total = buffer.size;
    let bytesDone = 0;
    while (true) {
      const { done, value } = await reader.read();
      if (done) {
        break;
      }
      sha2562.update(value);
      bytesDone += value.length;
      yield bytesDone / total;
      opts?.abortSignal?.throwIfAborted();
    }
    return sha2562.digest("hex");
  }
  if (!cryptoModule) {
    cryptoModule = await Promise.resolve().then(() => (init_sha256_node(), sha256_node_exports));
  }
  return yield* cryptoModule.sha256Node(buffer, { abortSignal: opts?.abortSignal });
}
var cryptoModule;
var wasmModule;

// src/utils/WebBlob.ts
var WebBlob = class extends Blob {
  static async create(url, opts) {
    const customFetch = opts?.fetch ?? fetch;
    const response = await customFetch(url, {
      method: "HEAD",
      ...opts?.accessToken && {
        headers: {
          Authorization: `Bearer ${opts.accessToken}`
        }
      }
    });
    const size = Number(response.headers.get("content-length"));
    const contentType = response.headers.get("content-type") || "";
    const supportRange = response.headers.get("accept-ranges") === "bytes";
    if (!supportRange || size < (opts?.cacheBelow ?? 1e6)) {
      return await (await customFetch(url)).blob();
    }
    return new WebBlob(url, 0, size, contentType, true, customFetch, opts?.accessToken);
  }
  url;
  start;
  end;
  contentType;
  full;
  fetch;
  accessToken;
  constructor(url, start, end, contentType, full, customFetch, accessToken) {
    super([]);
    this.url = url;
    this.start = start;
    this.end = end;
    this.contentType = contentType;
    this.full = full;
    this.fetch = customFetch;
    this.accessToken = accessToken;
  }
  get size() {
    return this.end - this.start;
  }
  get type() {
    return this.contentType;
  }
  slice(start = 0, end = this.size) {
    if (start < 0 || end < 0) {
      new TypeError("Unsupported negative start/end on WebBlob.slice");
    }
    const slice = new WebBlob(
      this.url,
      this.start + start,
      Math.min(this.start + end, this.end),
      this.contentType,
      start === 0 && end === this.size ? this.full : false,
      this.fetch,
      this.accessToken
    );
    return slice;
  }
  async arrayBuffer() {
    const result = await this.fetchRange();
    return result.arrayBuffer();
  }
  async text() {
    const result = await this.fetchRange();
    return result.text();
  }
  stream() {
    const stream = new TransformStream();
    this.fetchRange().then((response) => response.body?.pipeThrough(stream)).catch((error) => stream.writable.abort(error.message));
    return stream.readable;
  }
  fetchRange() {
    const fetch2 = this.fetch;
    if (this.full) {
      return fetch2(this.url, {
        ...this.accessToken && {
          headers: {
            Authorization: `Bearer ${this.accessToken}`
          }
        }
      }).then((resp) => resp.ok ? resp : createApiError(resp));
    }
    return fetch2(this.url, {
      headers: {
        Range: `bytes=${this.start}-${this.end - 1}`,
        ...this.accessToken && { Authorization: `Bearer ${this.accessToken}` }
      }
    }).then((resp) => resp.ok ? resp : createApiError(resp));
  }
};

// src/utils/base64FromBytes.ts
function base64FromBytes(arr) {
  if (globalThis.Buffer) {
    return globalThis.Buffer.from(arr).toString("base64");
  } else {
    const bin = [];
    arr.forEach((byte) => {
      bin.push(String.fromCharCode(byte));
    });
    return globalThis.btoa(bin.join(""));
  }
}

// src/utils/createBlobs.ts
async function createBlobs(url, destPath, opts) {
  if (url.protocol === "http:" || url.protocol === "https:") {
    const blob = await WebBlob.create(url, { fetch: opts?.fetch, accessToken: opts?.accessToken });
    return [{ path: destPath, blob }];
  }
  if (isFrontend) {
    throw new TypeError(`Unsupported URL protocol "${url.protocol}"`);
  }
  if (url.protocol === "file:") {
    const { FileBlob: FileBlob2 } = await Promise.resolve().then(() => (init_FileBlob(), FileBlob_exports));
    const { subPaths: subPaths2 } = await Promise.resolve().then(() => (init_sub_paths(), sub_paths_exports));
    const paths = await subPaths2(url, opts?.maxFolderDepth);
    if (paths.length === 1 && paths[0].relativePath === ".") {
      const blob = await FileBlob2.create(url);
      return [{ path: destPath, blob }];
    }
    return Promise.all(
      paths.map(async (path2) => ({
        path: `${destPath}/${path2.relativePath}`.replace(/\/[.]$/, "").replaceAll("//", "/").replace(/^[.]?\//, ""),
        blob: await FileBlob2.create(new URL(path2.path))
      }))
    );
  }
  throw new TypeError(`Unsupported URL protocol "${url.protocol}"`);
}

// src/vendor/lz4js/util.ts
function hashU32(a) {
  a = a | 0;
  a = a + 2127912214 + (a << 12) | 0;
  a = a ^ -949894596 ^ a >>> 19;
  a = a + 374761393 + (a << 5) | 0;
  a = a + -744332180 ^ a << 9;
  a = a + -42973499 + (a << 3) | 0;
  return a ^ -1252372727 ^ a >>> 16 | 0;
}
function readU64(b, n) {
  let x = 0;
  x |= b[n++] << 0;
  x |= b[n++] << 8;
  x |= b[n++] << 16;
  x |= b[n++] << 24;
  x |= b[n++] << 32;
  x |= b[n++] << 40;
  x |= b[n++] << 48;
  x |= b[n++] << 56;
  return x;
}
function readU32(b, n) {
  let x = 0;
  x |= b[n++] << 0;
  x |= b[n++] << 8;
  x |= b[n++] << 16;
  x |= b[n++] << 24;
  return x;
}
function writeU32(b, n, x) {
  b[n++] = x >> 0 & 255;
  b[n++] = x >> 8 & 255;
  b[n++] = x >> 16 & 255;
  b[n++] = x >> 24 & 255;
}
function imul(a, b) {
  const ah = a >>> 16;
  const al = a & 65535;
  const bh = b >>> 16;
  const bl = b & 65535;
  return al * bl + (ah * bl + al * bh << 16) | 0;
}

// src/vendor/lz4js/xxh32.ts
var prime1 = 2654435761;
var prime2 = 2246822519;
var prime3 = 3266489917;
var prime4 = 668265263;
var prime5 = 374761393;
function rotl32(x, r) {
  x = x | 0;
  r = r | 0;
  return x >>> (32 - r | 0) | x << r | 0;
}
function rotmul32(h, r, m) {
  h = h | 0;
  r = r | 0;
  m = m | 0;
  return imul(h >>> (32 - r | 0) | h << r, m) | 0;
}
function shiftxor32(h, s) {
  h = h | 0;
  s = s | 0;
  return h >>> s ^ h | 0;
}
function xxhapply(h, src, m0, s, m1) {
  return rotmul32(imul(src, m0) + h, s, m1);
}
function xxh1(h, src, index) {
  return rotmul32(h + imul(src[index], prime5), 11, prime1);
}
function xxh4(h, src, index) {
  return xxhapply(h, readU32(src, index), prime3, 17, prime4);
}
function xxh16(h, src, index) {
  return [
    xxhapply(h[0], readU32(src, index + 0), prime2, 13, prime1),
    xxhapply(h[1], readU32(src, index + 4), prime2, 13, prime1),
    xxhapply(h[2], readU32(src, index + 8), prime2, 13, prime1),
    xxhapply(h[3], readU32(src, index + 12), prime2, 13, prime1)
  ];
}
function xxh32(seed, src, index, len) {
  let h;
  const l = len;
  if (len >= 16) {
    h = [seed + prime1 + prime2, seed + prime2, seed, seed - prime1];
    while (len >= 16) {
      h = xxh16(h, src, index);
      index += 16;
      len -= 16;
    }
    h = rotl32(h[0], 1) + rotl32(h[1], 7) + rotl32(h[2], 12) + rotl32(h[3], 18) + l;
  } else {
    h = seed + prime5 + len >>> 0;
  }
  while (len >= 4) {
    h = xxh4(h, src, index);
    index += 4;
    len -= 4;
  }
  while (len > 0) {
    h = xxh1(h, src, index);
    index++;
    len--;
  }
  h = shiftxor32(imul(shiftxor32(imul(shiftxor32(h, 15), prime2), 13), prime3), 16);
  return h >>> 0;
}
var hash = xxh32;

// src/vendor/lz4js/index.ts
var minMatch = 4;
var matchSearchLimit = 12;
var minTrailingLitterals = 5;
var skipTrigger = 6;
var hashSize = 1 << 16;
var mlBits = 4;
var mlMask = (1 << mlBits) - 1;
var runBits = 4;
var runMask = (1 << runBits) - 1;
var blockBuf = makeBuffer(5 << 20);
var hashTable = makeHashTable();
var magicNum = 407708164;
var fdContentChksum = 4;
var fdContentSize = 8;
var fdBlockChksum = 16;
var fdVersion = 64;
var fdVersionMask = 192;
var bsUncompressed = 2147483648;
var bsDefault = 7;
var bsShift = 4;
var bsMask = 7;
var bsMap = {
  4: 65536,
  5: 262144,
  6: 1048576,
  7: 4194304
};
function makeHashTable() {
  try {
    return new Uint32Array(hashSize);
  } catch (error) {
    const hashTable2 = new Array(hashSize);
    for (let i = 0; i < hashSize; i++) {
      hashTable2[i] = 0;
    }
    return hashTable2;
  }
}
function clearHashTable(table) {
  for (let i = 0; i < hashSize; i++) {
    table[i] = 0;
  }
}
function makeBuffer(size) {
  return new Uint8Array(size);
}
function sliceArray(array, start, end) {
  return array.slice(start, end);
}
function compressBound(n) {
  return n + n / 255 + 16 | 0;
}
function decompressBound(src) {
  let sIndex = 0;
  if (readU32(src, sIndex) !== magicNum) {
    throw new Error("invalid magic number");
  }
  sIndex += 4;
  const descriptor = src[sIndex++];
  if ((descriptor & fdVersionMask) !== fdVersion) {
    throw new Error("incompatible descriptor version " + (descriptor & fdVersionMask));
  }
  const useBlockSum = (descriptor & fdBlockChksum) !== 0;
  const useContentSize = (descriptor & fdContentSize) !== 0;
  const bsIdx = src[sIndex++] >> bsShift & bsMask;
  if (bsMap[bsIdx] === void 0) {
    throw new Error("invalid block size " + bsIdx);
  }
  const maxBlockSize = bsMap[bsIdx];
  if (useContentSize) {
    return readU64(src, sIndex);
  }
  sIndex++;
  let maxSize = 0;
  while (true) {
    let blockSize = readU32(src, sIndex);
    sIndex += 4;
    if (blockSize & bsUncompressed) {
      blockSize &= ~bsUncompressed;
      maxSize += blockSize;
    } else if (blockSize > 0) {
      maxSize += maxBlockSize;
    }
    if (blockSize === 0) {
      return maxSize;
    }
    if (useBlockSum) {
      sIndex += 4;
    }
    sIndex += blockSize;
  }
}
function decompressBlock(src, dst, sIndex, sLength, dIndex) {
  let mLength, mOffset, sEnd, n, i;
  const hasCopyWithin = dst.copyWithin !== void 0 && dst.fill !== void 0;
  sEnd = sIndex + sLength;
  while (sIndex < sEnd) {
    const token = src[sIndex++];
    let literalCount = token >> 4;
    if (literalCount > 0) {
      if (literalCount === 15) {
        while (true) {
          literalCount += src[sIndex];
          if (src[sIndex++] !== 255) {
            break;
          }
        }
      }
      for (n = sIndex + literalCount; sIndex < n; ) {
        dst[dIndex++] = src[sIndex++];
      }
    }
    if (sIndex >= sEnd) {
      break;
    }
    mLength = token & 15;
    mOffset = src[sIndex++] | src[sIndex++] << 8;
    if (mLength === 15) {
      while (true) {
        mLength += src[sIndex];
        if (src[sIndex++] !== 255) {
          break;
        }
      }
    }
    mLength += minMatch;
    if (hasCopyWithin && mOffset === 1) {
      dst.fill(dst[dIndex - 1] | 0, dIndex, dIndex + mLength);
      dIndex += mLength;
    } else if (hasCopyWithin && mOffset > mLength && mLength > 31) {
      dst.copyWithin(dIndex, dIndex - mOffset, dIndex - mOffset + mLength);
      dIndex += mLength;
    } else {
      for (i = dIndex - mOffset, n = i + mLength; i < n; ) {
        dst[dIndex++] = dst[i++] | 0;
      }
    }
  }
  return dIndex;
}
function compressBlock(src, dst, sIndex, sLength, hashTable2) {
  let mIndex, mAnchor, mLength, mOffset, mStep;
  let literalCount, dIndex, sEnd, n;
  dIndex = 0;
  sEnd = sLength + sIndex;
  mAnchor = sIndex;
  let searchMatchCount = (1 << skipTrigger) + 3;
  while (sIndex <= sEnd - matchSearchLimit) {
    const seq = readU32(src, sIndex);
    let hash2 = hashU32(seq) >>> 0;
    hash2 = (hash2 >> 16 ^ hash2) >>> 0 & 65535;
    mIndex = hashTable2[hash2] - 1;
    hashTable2[hash2] = sIndex + 1;
    if (mIndex < 0 || sIndex - mIndex >>> 16 > 0 || readU32(src, mIndex) !== seq) {
      mStep = searchMatchCount++ >> skipTrigger;
      sIndex += mStep;
      continue;
    }
    searchMatchCount = (1 << skipTrigger) + 3;
    literalCount = sIndex - mAnchor;
    mOffset = sIndex - mIndex;
    sIndex += minMatch;
    mIndex += minMatch;
    mLength = sIndex;
    while (sIndex < sEnd - minTrailingLitterals && src[sIndex] === src[mIndex]) {
      sIndex++;
      mIndex++;
    }
    mLength = sIndex - mLength;
    const token = mLength < mlMask ? mLength : mlMask;
    if (literalCount >= runMask) {
      dst[dIndex++] = (runMask << mlBits) + token;
      for (n = literalCount - runMask; n >= 255; n -= 255) {
        dst[dIndex++] = 255;
      }
      dst[dIndex++] = n;
    } else {
      dst[dIndex++] = (literalCount << mlBits) + token;
    }
    for (let i = 0; i < literalCount; i++) {
      dst[dIndex++] = src[mAnchor + i];
    }
    dst[dIndex++] = mOffset;
    dst[dIndex++] = mOffset >> 8;
    if (mLength >= mlMask) {
      for (n = mLength - mlMask; n >= 255; n -= 255) {
        dst[dIndex++] = 255;
      }
      dst[dIndex++] = n;
    }
    mAnchor = sIndex;
  }
  if (mAnchor === 0) {
    return 0;
  }
  literalCount = sEnd - mAnchor;
  if (literalCount >= runMask) {
    dst[dIndex++] = runMask << mlBits;
    for (n = literalCount - runMask; n >= 255; n -= 255) {
      dst[dIndex++] = 255;
    }
    dst[dIndex++] = n;
  } else {
    dst[dIndex++] = literalCount << mlBits;
  }
  sIndex = mAnchor;
  while (sIndex < sEnd) {
    dst[dIndex++] = src[sIndex++];
  }
  return dIndex;
}
function decompressFrame(src, dst) {
  let useBlockSum, useContentSum, useContentSize, descriptor;
  let sIndex = 0;
  let dIndex = 0;
  if (readU32(src, sIndex) !== magicNum) {
    throw new Error("invalid magic number");
  }
  sIndex += 4;
  descriptor = src[sIndex++];
  if ((descriptor & fdVersionMask) !== fdVersion) {
    throw new Error("incompatible descriptor version");
  }
  useBlockSum = (descriptor & fdBlockChksum) !== 0;
  useContentSum = (descriptor & fdContentChksum) !== 0;
  useContentSize = (descriptor & fdContentSize) !== 0;
  const bsIdx = src[sIndex++] >> bsShift & bsMask;
  if (bsMap[bsIdx] === void 0) {
    throw new Error("invalid block size");
  }
  if (useContentSize) {
    sIndex += 8;
  }
  sIndex++;
  while (true) {
    var compSize;
    compSize = readU32(src, sIndex);
    sIndex += 4;
    if (compSize === 0) {
      break;
    }
    if (useBlockSum) {
      sIndex += 4;
    }
    if ((compSize & bsUncompressed) !== 0) {
      compSize &= ~bsUncompressed;
      for (let j = 0; j < compSize; j++) {
        dst[dIndex++] = src[sIndex++];
      }
    } else {
      dIndex = decompressBlock(src, dst, sIndex, compSize, dIndex);
      sIndex += compSize;
    }
  }
  if (useContentSum) {
    sIndex += 4;
  }
  return dIndex;
}
function compressFrame(src, dst) {
  let dIndex = 0;
  writeU32(dst, dIndex, magicNum);
  dIndex += 4;
  dst[dIndex++] = fdVersion;
  dst[dIndex++] = bsDefault << bsShift;
  dst[dIndex] = hash(0, dst, 4, dIndex - 4) >> 8;
  dIndex++;
  const maxBlockSize = bsMap[bsDefault];
  let remaining = src.length;
  let sIndex = 0;
  clearHashTable(hashTable);
  while (remaining > 0) {
    let compSize = 0;
    const blockSize = remaining > maxBlockSize ? maxBlockSize : remaining;
    compSize = compressBlock(src, blockBuf, sIndex, blockSize, hashTable);
    if (compSize > blockSize || compSize === 0) {
      writeU32(dst, dIndex, 2147483648 | blockSize);
      dIndex += 4;
      for (let z = sIndex + blockSize; sIndex < z; ) {
        dst[dIndex++] = src[sIndex++];
      }
      remaining -= blockSize;
    } else {
      writeU32(dst, dIndex, compSize);
      dIndex += 4;
      for (let j = 0; j < compSize; ) {
        dst[dIndex++] = blockBuf[j++];
      }
      sIndex += blockSize;
      remaining -= blockSize;
    }
  }
  writeU32(dst, dIndex, 0);
  dIndex += 4;
  return dIndex;
}
function decompress(src, maxSize) {
  let dst, size;
  if (maxSize === void 0) {
    maxSize = decompressBound(src);
  }
  dst = makeBuffer(maxSize);
  size = decompressFrame(src, dst);
  if (size !== maxSize) {
    dst = sliceArray(dst, 0, size);
  }
  return dst;
}
function compress(src, maxSize) {
  let dst, size;
  if (maxSize === void 0) {
    maxSize = compressBound(src.length);
  }
  dst = makeBuffer(maxSize);
  size = compressFrame(src, dst);
  if (size !== maxSize) {
    dst = sliceArray(dst, 0, size);
  }
  return dst;
}

// src/utils/RangeList.ts
var RangeList = class {
  ranges = [];
  /**
   * Add a range to the list. If it overlaps with existing ranges,
   * it will split them and increment reference counts accordingly.
   */
  add(start, end) {
    if (end <= start) {
      throw new TypeError("End must be greater than start");
    }
    const overlappingRanges = [];
    for (let i = 0; i < this.ranges.length; i++) {
      const range2 = this.ranges[i];
      if (start < range2.end && end > range2.start) {
        overlappingRanges.push({ index: i, range: range2 });
      }
      if (range2.data !== null) {
        throw new Error("Overlapping range already has data");
      }
    }
    if (overlappingRanges.length === 0) {
      this.ranges.push({ start, end, refCount: 1, data: null });
      this.ranges.sort((a, b) => a.start - b.start);
      return;
    }
    const newRanges = [];
    let currentPos = start;
    for (let i = 0; i < overlappingRanges.length; i++) {
      const { range: range2 } = overlappingRanges[i];
      if (currentPos < range2.start) {
        newRanges.push({
          start: currentPos,
          end: range2.start,
          refCount: 1,
          data: null
        });
      } else if (range2.start < currentPos) {
        newRanges.push({
          start: range2.start,
          end: currentPos,
          refCount: range2.refCount,
          data: null
        });
      }
      newRanges.push({
        start: Math.max(currentPos, range2.start),
        end: Math.min(end, range2.end),
        refCount: range2.refCount + 1,
        data: null
      });
      if (range2.end > end) {
        newRanges.push({
          start: end,
          end: range2.end,
          refCount: range2.refCount,
          data: null
        });
      }
      currentPos = Math.max(currentPos, range2.end);
    }
    if (currentPos < end) {
      newRanges.push({
        start: currentPos,
        end,
        refCount: 1,
        data: null
      });
    }
    const firstIndex = overlappingRanges[0].index;
    const lastIndex = overlappingRanges[overlappingRanges.length - 1].index;
    this.ranges.splice(firstIndex, lastIndex - firstIndex + 1, ...newRanges);
    this.ranges.sort((a, b) => a.start - b.start);
  }
  /**
   * Remove a range from the list. The range must start and end at existing boundaries.
   */
  remove(start, end) {
    if (end <= start) {
      throw new TypeError("End must be greater than start");
    }
    const affectedRanges = [];
    for (let i = 0; i < this.ranges.length; i++) {
      const range2 = this.ranges[i];
      if (start < range2.end && end > range2.start) {
        affectedRanges.push({ index: i, range: range2 });
      }
    }
    if (affectedRanges.length === 0) {
      throw new Error("No ranges found to remove");
    }
    if (start !== affectedRanges[0].range.start || end !== affectedRanges[affectedRanges.length - 1].range.end) {
      throw new Error("Range boundaries must match existing boundaries");
    }
    for (let i = 0; i < affectedRanges.length; i++) {
      const { range: range2 } = affectedRanges[i];
      range2.refCount--;
    }
    this.ranges = this.ranges.filter((range2) => range2.refCount > 0);
  }
  /**
   * Get all ranges within the specified boundaries.
   */
  getRanges(start, end) {
    if (end <= start) {
      throw new TypeError("End must be greater than start");
    }
    return this.ranges.filter((range2) => start < range2.end && end > range2.start);
  }
  /**
   * Get all ranges in the list
   */
  getAllRanges() {
    return [...this.ranges];
  }
};

// src/utils/XetBlob.ts
var JWT_SAFETY_PERIOD = 6e4;
var JWT_CACHE_SIZE = 1e3;
var compressionSchemeLabels = {
  [0 /* None */]: "None",
  [1 /* LZ4 */]: "LZ4",
  [2 /* ByteGroupingLZ4 */]: "ByteGroupingLZ4"
};
var XET_CHUNK_HEADER_BYTES = 8;
var XetBlob = class extends Blob {
  fetch;
  accessToken;
  refreshUrl;
  reconstructionUrl;
  hash;
  start = 0;
  end = 0;
  internalLogging = false;
  reconstructionInfo;
  listener;
  constructor(params) {
    super([]);
    this.fetch = params.fetch ?? fetch.bind(globalThis);
    this.accessToken = checkCredentials(params);
    this.refreshUrl = params.refreshUrl;
    this.end = params.size;
    this.reconstructionUrl = params.reconstructionUrl;
    this.hash = params.hash;
    this.listener = params.listener;
    this.internalLogging = params.internalLogging ?? false;
    this.refreshUrl;
  }
  get size() {
    return this.end - this.start;
  }
  #clone() {
    const blob = new XetBlob({
      fetch: this.fetch,
      hash: this.hash,
      refreshUrl: this.refreshUrl,
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      reconstructionUrl: this.reconstructionUrl,
      size: this.size
    });
    blob.accessToken = this.accessToken;
    blob.start = this.start;
    blob.end = this.end;
    blob.reconstructionInfo = this.reconstructionInfo;
    blob.listener = this.listener;
    blob.internalLogging = this.internalLogging;
    return blob;
  }
  slice(start = 0, end = this.size) {
    if (start < 0 || end < 0) {
      new TypeError("Unsupported negative start/end on XetBlob.slice");
    }
    const slice = this.#clone();
    slice.start = this.start + start;
    slice.end = Math.min(this.start + end, this.end);
    if (slice.start !== this.start || slice.end !== this.end) {
      slice.reconstructionInfo = void 0;
    }
    return slice;
  }
  #reconstructionInfoPromise;
  #loadReconstructionInfo() {
    if (this.#reconstructionInfoPromise) {
      return this.#reconstructionInfoPromise;
    }
    this.#reconstructionInfoPromise = (async () => {
      const connParams = await getAccessToken(this.accessToken, this.fetch, this.refreshUrl);
      const resp = await this.fetch(this.reconstructionUrl ?? `${connParams.casUrl}/v1/reconstruction/${this.hash}`, {
        headers: {
          Authorization: `Bearer ${connParams.accessToken}`,
          Range: `bytes=${this.start}-${this.end - 1}`
        }
      });
      if (!resp.ok) {
        throw await createApiError(resp);
      }
      this.reconstructionInfo = await resp.json();
      return this.reconstructionInfo;
    })().finally(() => this.#reconstructionInfoPromise = void 0);
    return this.#reconstructionInfoPromise;
  }
  async #fetch() {
    if (!this.reconstructionInfo) {
      await this.#loadReconstructionInfo();
    }
    const rangeLists = /* @__PURE__ */ new Map();
    if (!this.reconstructionInfo) {
      throw new Error("Failed to load reconstruction info");
    }
    for (const term of this.reconstructionInfo.terms) {
      let rangeList = rangeLists.get(term.hash);
      if (!rangeList) {
        rangeList = new RangeList();
        rangeLists.set(term.hash, rangeList);
      }
      rangeList.add(term.range.start, term.range.end);
    }
    const listener = this.listener;
    const log = this.internalLogging ? (...args) => console.log(...args) : () => {
    };
    async function* readData(reconstructionInfo, customFetch, maxBytes, reloadReconstructionInfo) {
      let totalBytesRead = 0;
      let readBytesToSkip = reconstructionInfo.offset_into_first_range;
      for (const term of reconstructionInfo.terms) {
        if (totalBytesRead >= maxBytes) {
          break;
        }
        const rangeList = rangeLists.get(term.hash);
        if (!rangeList) {
          throw new Error(`Failed to find range list for term ${term.hash}`);
        }
        {
          const termRanges = rangeList.getRanges(term.range.start, term.range.end);
          if (termRanges.every((range2) => range2.data)) {
            log("all data available for term", term.hash, readBytesToSkip);
            rangeLoop:
              for (const range2 of termRanges) {
                for (let chunk2 of range2.data) {
                  if (readBytesToSkip) {
                    const skipped = Math.min(readBytesToSkip, chunk2.byteLength);
                    chunk2 = chunk2.slice(skipped);
                    readBytesToSkip -= skipped;
                    if (!chunk2.byteLength) {
                      continue;
                    }
                  }
                  if (chunk2.byteLength > maxBytes - totalBytesRead) {
                    chunk2 = chunk2.slice(0, maxBytes - totalBytesRead);
                  }
                  totalBytesRead += chunk2.byteLength;
                  yield range2.refCount > 1 ? chunk2.slice() : chunk2;
                  listener?.({ event: "progress", progress: { read: totalBytesRead, total: maxBytes } });
                  if (totalBytesRead >= maxBytes) {
                    break rangeLoop;
                  }
                }
              }
            rangeList.remove(term.range.start, term.range.end);
            continue;
          }
        }
        const fetchInfo = reconstructionInfo.fetch_info[term.hash].find(
          (info) => info.range.start <= term.range.start && info.range.end >= term.range.end
        );
        if (!fetchInfo) {
          throw new Error(
            `Failed to find fetch info for term ${term.hash} and range ${term.range.start}-${term.range.end}`
          );
        }
        log("term", term);
        log("fetchinfo", fetchInfo);
        log("readBytesToSkip", readBytesToSkip);
        let resp = await customFetch(fetchInfo.url, {
          headers: {
            Range: `bytes=${fetchInfo.url_range.start}-${fetchInfo.url_range.end}`
          }
        });
        if (resp.status === 403) {
          reconstructionInfo = await reloadReconstructionInfo();
          resp = await customFetch(fetchInfo.url, {
            headers: {
              Range: `bytes=${fetchInfo.url_range.start}-${fetchInfo.url_range.end}`
            }
          });
        }
        if (!resp.ok) {
          throw await createApiError(resp);
        }
        log(
          "expected content length",
          resp.headers.get("content-length"),
          "range",
          fetchInfo.url_range,
          resp.headers.get("content-range")
        );
        const reader = resp.body?.getReader();
        if (!reader) {
          throw new Error("Failed to get reader from response body");
        }
        let done = false;
        let chunkIndex = fetchInfo.range.start;
        const ranges = rangeList.getRanges(fetchInfo.range.start, fetchInfo.range.end);
        let leftoverBytes = void 0;
        let totalFetchBytes = 0;
        fetchData:
          while (!done && totalBytesRead < maxBytes) {
            const result = await reader.read();
            listener?.({ event: "read" });
            done = result.done;
            log("read", result.value?.byteLength, "bytes", "total read", totalBytesRead, "toSkip", readBytesToSkip);
            if (!result.value) {
              log("no data in result, cancelled", result);
              continue;
            }
            totalFetchBytes += result.value.byteLength;
            if (leftoverBytes) {
              result.value = new Uint8Array([...leftoverBytes, ...result.value]);
              leftoverBytes = void 0;
            }
            while (totalBytesRead < maxBytes && result.value.byteLength) {
              if (result.value.byteLength < 8) {
                leftoverBytes = result.value;
                continue fetchData;
              }
              const header = new DataView(result.value.buffer, result.value.byteOffset, XET_CHUNK_HEADER_BYTES);
              const chunkHeader = {
                version: header.getUint8(0),
                compressed_length: header.getUint8(1) | header.getUint8(2) << 8 | header.getUint8(3) << 16,
                compression_scheme: header.getUint8(4),
                uncompressed_length: header.getUint8(5) | header.getUint8(6) << 8 | header.getUint8(7) << 16
              };
              log("chunk header", chunkHeader, "to skip", readBytesToSkip);
              if (chunkHeader.version !== 0) {
                throw new Error(`Unsupported chunk version ${chunkHeader.version}`);
              }
              if (chunkHeader.compression_scheme !== 0 /* None */ && chunkHeader.compression_scheme !== 1 /* LZ4 */ && chunkHeader.compression_scheme !== 2 /* ByteGroupingLZ4 */) {
                throw new Error(
                  `Unsupported compression scheme ${compressionSchemeLabels[chunkHeader.compression_scheme] ?? chunkHeader.compression_scheme}`
                );
              }
              if (result.value.byteLength < chunkHeader.compressed_length + XET_CHUNK_HEADER_BYTES) {
                leftoverBytes = result.value;
                continue fetchData;
              }
              result.value = result.value.slice(XET_CHUNK_HEADER_BYTES);
              let uncompressed = chunkHeader.compression_scheme === 1 /* LZ4 */ ? decompress(result.value.slice(0, chunkHeader.compressed_length), chunkHeader.uncompressed_length) : chunkHeader.compression_scheme === 2 /* ByteGroupingLZ4 */ ? bg4_regroup_bytes(
                decompress(
                  result.value.slice(0, chunkHeader.compressed_length),
                  chunkHeader.uncompressed_length
                )
              ) : result.value.slice(0, chunkHeader.compressed_length);
              const range2 = ranges.find((range3) => chunkIndex >= range3.start && chunkIndex < range3.end);
              const shouldYield = chunkIndex >= term.range.start && chunkIndex < term.range.end;
              const minRefCountToStore = shouldYield ? 2 : 1;
              let stored = false;
              if (range2 && range2.refCount >= minRefCountToStore) {
                range2.data ??= [];
                range2.data.push(uncompressed);
                stored = true;
              }
              if (shouldYield) {
                if (readBytesToSkip) {
                  const skipped = Math.min(readBytesToSkip, uncompressed.byteLength);
                  uncompressed = uncompressed.slice(readBytesToSkip);
                  readBytesToSkip -= skipped;
                }
                if (uncompressed.byteLength > maxBytes - totalBytesRead) {
                  uncompressed = uncompressed.slice(0, maxBytes - totalBytesRead);
                }
                if (uncompressed.byteLength) {
                  log(
                    "yield",
                    uncompressed.byteLength,
                    "bytes",
                    result.value.byteLength,
                    "total read",
                    totalBytesRead,
                    stored
                  );
                  totalBytesRead += uncompressed.byteLength;
                  yield stored ? uncompressed.slice() : uncompressed;
                  listener?.({ event: "progress", progress: { read: totalBytesRead, total: maxBytes } });
                }
              }
              chunkIndex++;
              result.value = result.value.slice(chunkHeader.compressed_length);
            }
          }
        if (done && totalBytesRead < maxBytes && totalFetchBytes < fetchInfo.url_range.end - fetchInfo.url_range.start + 1) {
          log("done", done, "total read", totalBytesRead, maxBytes, totalFetchBytes);
          log("failed to fetch all data for term", term.hash);
          throw new Error(
            `Failed to fetch all data for term ${term.hash}, fetched ${totalFetchBytes} bytes out of ${fetchInfo.url_range.end - fetchInfo.url_range.start + 1}`
          );
        }
        log("done", done, "total read", totalBytesRead, maxBytes, totalFetchBytes);
        log("cancel reader");
        await reader.cancel();
      }
    }
    const iterator = readData(
      this.reconstructionInfo,
      this.fetch,
      this.end - this.start,
      this.#loadReconstructionInfo.bind(this)
    );
    return new ReadableStream(
      {
        // todo: when Safari supports it, type controller as ReadableByteStreamController
        async pull(controller) {
          const result = await iterator.next();
          if (result.value) {
            controller.enqueue(result.value);
          }
          if (result.done) {
            controller.close();
          }
        },
        type: "bytes"
        // todo: when Safari supports it, add autoAllocateChunkSize param
      },
      // todo : use ByteLengthQueuingStrategy when there's good support for it, currently in Node.js it fails due to size being a function
      {
        highWaterMark: 1e3
        // 1_000 chunks for ~1MB of RAM
      }
    );
  }
  async arrayBuffer() {
    const result = await this.#fetch();
    return new Response(result).arrayBuffer();
  }
  async text() {
    const result = await this.#fetch();
    return new Response(result).text();
  }
  async response() {
    const result = await this.#fetch();
    return new Response(result);
  }
  stream() {
    const stream = new TransformStream();
    this.#fetch().then((response) => response.pipeThrough(stream)).catch((error) => stream.writable.abort(error.message));
    return stream.readable;
  }
};
var jwtPromises = /* @__PURE__ */ new Map();
var jwts = /* @__PURE__ */ new Map();
function cacheKey(params) {
  return JSON.stringify([params.refreshUrl, params.initialAccessToken]);
}
function bg4_regroup_bytes(bytes) {
  const split = Math.floor(bytes.byteLength / 4);
  const rem = bytes.byteLength % 4;
  const g1_pos = split + (rem >= 1 ? 1 : 0);
  const g2_pos = g1_pos + split + (rem >= 2 ? 1 : 0);
  const g3_pos = g2_pos + split + (rem == 3 ? 1 : 0);
  const ret = new Uint8Array(bytes.byteLength);
  for (let i = 0, j = 0; i < bytes.byteLength; i += 4, j++) {
    ret[i] = bytes[j];
  }
  for (let i = 1, j = g1_pos; i < bytes.byteLength; i += 4, j++) {
    ret[i] = bytes[j];
  }
  for (let i = 2, j = g2_pos; i < bytes.byteLength; i += 4, j++) {
    ret[i] = bytes[j];
  }
  for (let i = 3, j = g3_pos; i < bytes.byteLength; i += 4, j++) {
    ret[i] = bytes[j];
  }
  return ret;
}
function bg4_split_bytes(bytes) {
  const ret = new Uint8Array(bytes.byteLength);
  const split = Math.floor(bytes.byteLength / 4);
  const rem = bytes.byteLength % 4;
  const g1_pos = split + (rem >= 1 ? 1 : 0);
  const g2_pos = g1_pos + split + (rem >= 2 ? 1 : 0);
  const g3_pos = g2_pos + split + (rem == 3 ? 1 : 0);
  for (let i = 0, j = 0; i < bytes.byteLength; i += 4, j++) {
    ret[j] = bytes[i];
  }
  for (let i = 1, j = g1_pos; i < bytes.byteLength; i += 4, j++) {
    ret[j] = bytes[i];
  }
  for (let i = 2, j = g2_pos; i < bytes.byteLength; i += 4, j++) {
    ret[j] = bytes[i];
  }
  for (let i = 3, j = g3_pos; i < bytes.byteLength; i += 4, j++) {
    ret[j] = bytes[i];
  }
  return ret;
}
async function getAccessToken(initialAccessToken, customFetch, refreshUrl) {
  const key = cacheKey({ refreshUrl, initialAccessToken });
  const jwt = jwts.get(key);
  if (jwt && jwt.expiresAt > new Date(Date.now() + JWT_SAFETY_PERIOD)) {
    return { accessToken: jwt.accessToken, casUrl: jwt.casUrl };
  }
  const existingPromise = jwtPromises.get(key);
  if (existingPromise) {
    return existingPromise;
  }
  const promise = (async () => {
    const resp = await customFetch(refreshUrl, {
      headers: {
        ...initialAccessToken ? {
          Authorization: `Bearer ${initialAccessToken}`
        } : {}
      }
    });
    if (!resp.ok) {
      throw new Error(`Failed to get JWT token: ${resp.status} ${await resp.text()}`);
    }
    const json = await resp.json();
    const jwt2 = {
      accessToken: json.accessToken,
      expiresAt: new Date(json.exp * 1e3),
      casUrl: json.casUrl
    };
    jwtPromises.delete(key);
    for (const [key2, value] of jwts.entries()) {
      if (value.expiresAt < new Date(Date.now() + JWT_SAFETY_PERIOD)) {
        jwts.delete(key2);
      } else {
        break;
      }
    }
    if (jwts.size >= JWT_CACHE_SIZE) {
      const keyToDelete = jwts.keys().next().value;
      if (keyToDelete) {
        jwts.delete(keyToDelete);
      }
    }
    jwts.set(key, jwt2);
    return {
      accessToken: json.accessToken,
      casUrl: json.casUrl
    };
  })();
  jwtPromises.set(key, promise);
  return promise;
}

// src/utils/ChunkCache.ts
var CHUNK_CACHE_INITIAL_SIZE = 1e4;
var CHUNK_CACHE_GROW_FACTOR = 1.5;
var CHUNK_CACHE_MAX_SIZE = 1e6;
var ChunkCache = class {
  index = 0;
  // Index >= 0 means local xorb, < 0 means remote xorb
  xorbIndices = new Int32Array(CHUNK_CACHE_INITIAL_SIZE);
  // Max 8K chunks per xorb, less than 64K uint16_t
  chunkIndices = new Uint16Array(CHUNK_CACHE_INITIAL_SIZE);
  map = /* @__PURE__ */ new Map();
  // hash -> chunkCacheIndex. Less overhead that way, empty object is 60+B and empty array is 40+B
  hmacs = /* @__PURE__ */ new Set();
  // todo : remove old hmacs
  addChunkToCache(hash2, xorbIndex, chunkIndex, hmac) {
    this.map.set(hash2, this.index);
    if (hmac !== null) {
      this.hmacs.add(hmac);
    }
    if (this.index >= this.xorbIndices.length) {
      const oldXorbIndices = this.xorbIndices;
      const oldChunkIndices = this.chunkIndices;
      this.xorbIndices = new Int32Array(
        Math.min(this.xorbIndices.length * CHUNK_CACHE_GROW_FACTOR, CHUNK_CACHE_MAX_SIZE)
      );
      this.chunkIndices = new Uint16Array(
        Math.min(this.chunkIndices.length * CHUNK_CACHE_GROW_FACTOR, CHUNK_CACHE_MAX_SIZE)
      );
      this.xorbIndices.set(oldXorbIndices);
      this.chunkIndices.set(oldChunkIndices);
    }
    this.xorbIndices[this.index] = xorbIndex;
    this.chunkIndices[this.index] = chunkIndex;
    this.index = (this.index + 1) % CHUNK_CACHE_MAX_SIZE;
    while (this.map.size > CHUNK_CACHE_MAX_SIZE) {
      this.map.delete(this.map.keys().next().value);
    }
  }
  getChunk(hash2, hmacFunction) {
    let index = this.map.get(hash2);
    if (index === void 0 && hmacFunction !== null) {
      for (const hmac of this.hmacs) {
        index = this.map.get(hmacFunction(hash2, hmac));
        if (index !== void 0) {
          break;
        }
      }
    }
    if (index === void 0) {
      return void 0;
    }
    return {
      xorbIndex: this.xorbIndices[index],
      chunkIndex: this.chunkIndices[index]
    };
  }
  removeChunkFromCache(hash2) {
    this.map.delete(hash2);
  }
};

// src/utils/xetWriteToken.ts
var JWT_SAFETY_PERIOD2 = 6e4;
var JWT_CACHE_SIZE2 = 1e3;
function cacheKey2(params) {
  return JSON.stringify([params.hubUrl, params.repo, params.rev, params.accessToken]);
}
var jwtPromises2 = /* @__PURE__ */ new Map();
var jwts2 = /* @__PURE__ */ new Map();
async function xetWriteToken(params) {
  const key = cacheKey2(params);
  const jwt = jwts2.get(key);
  if (jwt && jwt.expiresAt > new Date(Date.now() + JWT_SAFETY_PERIOD2)) {
    return { accessToken: jwt.accessToken, casUrl: jwt.casUrl };
  }
  const existingPromise = jwtPromises2.get(key);
  if (existingPromise) {
    return existingPromise;
  }
  const promise = (async () => {
    const resp = await params.customFetch(
      `${params.hubUrl}/api/${params.repo.type}s/${params.repo.name}/xet-write-token/${params.rev}`,
      {
        headers: params.accessToken ? {
          Authorization: `Bearer ${params.accessToken}`
        } : {}
      }
    );
    if (!resp.ok) {
      throw await createApiError(resp);
    }
    const json = await resp.json();
    const jwt2 = {
      accessToken: json.accessToken,
      expiresAt: new Date(json.exp * 1e3),
      casUrl: json.casUrl
    };
    jwtPromises2.delete(key);
    for (const [key2, value] of jwts2.entries()) {
      if (value.expiresAt < new Date(Date.now() + JWT_SAFETY_PERIOD2)) {
        jwts2.delete(key2);
      } else {
        break;
      }
    }
    if (jwts2.size >= JWT_CACHE_SIZE2) {
      const keyToDelete = jwts2.keys().next().value;
      if (keyToDelete) {
        jwts2.delete(keyToDelete);
      }
    }
    jwts2.set(key, jwt2);
    return {
      accessToken: json.accessToken,
      casUrl: json.casUrl
    };
  })();
  jwtPromises2.set(key, promise);
  return promise;
}

// src/utils/shardParser.ts
var HASH_LENGTH = 32;
var XORB_HASH_BOOKEND = "ff".repeat(HASH_LENGTH);
function readHashFromArray(array, offset) {
  let hash2 = "";
  for (let i = 0; i < HASH_LENGTH; i += 8) {
    hash2 += `${array[offset + i + 7].toString(16).padStart(2, "0")}${array[offset + i + 6].toString(16).padStart(2, "0")}${array[offset + i + 5].toString(16).padStart(2, "0")}${array[offset + i + 4].toString(16).padStart(2, "0")}${array[offset + i + 3].toString(16).padStart(2, "0")}${array[offset + i + 2].toString(16).padStart(2, "0")}${array[offset + i + 1].toString(16).padStart(2, "0")}${array[offset + i].toString(16).padStart(2, "0")}`;
  }
  return hash2;
}
async function parseShardData(shardBlob) {
  const shard = new Uint8Array(await shardBlob.arrayBuffer());
  const shardView = new DataView(shard.buffer);
  const magicTag = shard.slice(0, SHARD_MAGIC_TAG.length);
  if (!magicTag.every((byte, i) => byte === SHARD_MAGIC_TAG[i])) {
    throw new Error("Invalid shard magic tag");
  }
  const version = shardView.getBigUint64(SHARD_MAGIC_TAG.length, true);
  if (version !== SHARD_HEADER_VERSION) {
    throw new Error(`Invalid shard version: ${version}`);
  }
  const footerSize = Number(shardView.getBigUint64(SHARD_MAGIC_TAG.length + 8, true));
  const footerStart = shard.length - footerSize;
  const footerVersion = shardView.getBigUint64(footerStart, true);
  if (footerVersion !== SHARD_FOOTER_VERSION) {
    throw new Error(`Invalid shard footer version: ${footerVersion}`);
  }
  const xorbInfoStart = Number(shardView.getBigUint64(footerStart + 16, true));
  const fileLookupStart = Number(shardView.getBigUint64(footerStart + 24, true));
  const hmacKey = readHashFromArray(shard, footerStart + 72);
  const xorbs = [];
  let offset = xorbInfoStart;
  while (offset < fileLookupStart) {
    const xorbHash = readHashFromArray(shard, offset);
    offset += HASH_LENGTH;
    if (xorbHash === XORB_HASH_BOOKEND) {
      break;
    }
    offset += 4;
    const chunkCount = shardView.getUint32(offset, true);
    offset += 4;
    offset += 4;
    offset += 4;
    const chunks = [];
    for (let i = 0; i < chunkCount; i++) {
      const chunkHash = readHashFromArray(shard, offset);
      offset += HASH_LENGTH;
      const startOffset = shardView.getUint32(offset, true);
      offset += 4;
      const length = shardView.getUint32(offset, true);
      offset += 4;
      offset += 8;
      chunks.push({
        hash: chunkHash,
        startOffset,
        unpackedLength: length
      });
    }
    xorbs.push({
      hash: xorbHash,
      chunks
    });
  }
  return {
    hmacKey,
    xorbs
  };
}

// src/utils/createXorbs.ts
var TARGET_CHUNK_SIZE = 64 * 1024;
var MAX_CHUNK_SIZE = 2 * TARGET_CHUNK_SIZE;
var XORB_SIZE = 64 * 1024 * 1024;
var MAX_XORB_CHUNKS = 8 * 1024;
var INTERVAL_BETWEEN_REMOTE_DEDUP = 4e6;
var CurrentXorbInfo = class {
  id;
  offset;
  chunks;
  /**
   * path => 0..1 mapping of the current xorb
   *
   * eg
   *
   * A => 1
   * B => 1
   * C => 0.345
   *
   * If the xorb contains the end of file A, B, and up to 34.5% of file C
   */
  fileProgress;
  data;
  immutableData;
  constructor() {
    this.id = 0;
    this.offset = 0;
    this.chunks = [];
    this.fileProgress = {};
    this.data = new Uint8Array(XORB_SIZE);
    this.immutableData = null;
  }
  event(computeXorbHash) {
    const xorbChunksCleaned = this.chunks.map((chunk2) => ({
      hash: chunk2.hash,
      length: chunk2.length
    }));
    return {
      event: "xorb",
      xorb: this.data.subarray(0, this.offset),
      hash: computeXorbHash(xorbChunksCleaned),
      chunks: xorbChunksCleaned,
      id: this.id,
      files: Object.entries(this.fileProgress).map(([path2, progress]) => ({ path: path2, progress }))
    };
  }
};
async function* createXorbs(fileSources, params) {
  const chunkModule = await Promise.resolve().then(() => (init_chunker_wasm(), chunker_wasm_exports));
  let xorbId = 0;
  await chunkModule.init();
  const chunker = new chunkModule.Chunker(TARGET_CHUNK_SIZE);
  const chunkCache = new ChunkCache();
  let xorb = new CurrentXorbInfo();
  const nextXorb = () => {
    const event = xorb.event(chunkModule.compute_xorb_hash.bind(chunkModule));
    xorbId++;
    xorb = new CurrentXorbInfo();
    xorb.id = xorbId;
    return event;
  };
  const pendingFileEvents = [];
  const remoteXorbHashes = [""];
  try {
    for await (const fileSource of fileSources) {
      let bytesSinceRemoteDedup = Infinity;
      const sourceChunks = [];
      const reader = fileSource.content.stream().getReader();
      let processedBytes = 0;
      let dedupedBytes = 0;
      const fileChunks = [];
      const chunkMetadata = [];
      const addChunks = async function* (chunks) {
        for (const chunk2 of chunks) {
          let chunkIndex = xorb.chunks.length;
          let chunkXorbId = xorbId;
          fileChunks.push({ hash: chunk2.hash, length: chunk2.length });
          let chunkToCopy;
          if (chunk2.length === sourceChunks[0].length) {
            chunkToCopy = sourceChunks[0];
            sourceChunks.shift();
          } else if (chunk2.length < sourceChunks[0].length) {
            chunkToCopy = sourceChunks[0].subarray(0, chunk2.length);
            sourceChunks[0] = sourceChunks[0].subarray(chunk2.length);
          } else {
            chunkToCopy = new Uint8Array(chunk2.length);
            let copyOffset = 0;
            let index = 0;
            let toSlice = -1;
            while (copyOffset < chunk2.length) {
              const nToCopy = Math.min(sourceChunks[index].length, chunk2.length - copyOffset);
              chunkToCopy.set(sourceChunks[index].subarray(0, nToCopy), copyOffset);
              copyOffset += nToCopy;
              if (nToCopy === sourceChunks[index].length) {
                index++;
              } else {
                toSlice = nToCopy;
              }
            }
            sourceChunks.splice(0, index);
            if (toSlice !== -1) {
              sourceChunks[0] = sourceChunks[0].subarray(toSlice);
            }
          }
          let cacheData = chunkCache.getChunk(chunk2.hash, chunkModule.compute_hmac);
          if (cacheData === void 0 && chunk2.dedup && bytesSinceRemoteDedup >= INTERVAL_BETWEEN_REMOTE_DEDUP) {
            const token = await xetWriteToken(params);
            bytesSinceRemoteDedup = 0;
            const shardResp = await params.customFetch(token.casUrl + "/v1/chunk/default/" + chunk2.hash, {
              headers: {
                Authorization: `Bearer ${token.accessToken}`
              }
            });
            if (shardResp.ok) {
              const shard = await shardResp.blob();
              const shardData = await parseShardData(shard);
              for (const xorb2 of shardData.xorbs) {
                const remoteXorbId = -remoteXorbHashes.length;
                remoteXorbHashes.push(xorb2.hash);
                let i = 0;
                for (const chunk3 of xorb2.chunks) {
                  chunkCache.addChunkToCache(chunk3.hash, remoteXorbId, i++, shardData.hmacKey);
                }
              }
              cacheData = chunkCache.getChunk(chunk2.hash, chunkModule.compute_hmac);
              dedupedBytes = backtrackDedup(
                xorb,
                chunkModule.compute_hmac.bind(chunkModule),
                shardData,
                chunkCache,
                chunkMetadata,
                dedupedBytes
              );
            }
          }
          if (cacheData === void 0) {
            if (!writeChunk(xorb, chunkToCopy, chunk2.hash)) {
              yield nextXorb();
              chunkIndex = 0;
              chunkXorbId = xorbId;
              for (const event of pendingFileEvents) {
                event.representation = event.representation.map((rep) => ({
                  ...rep,
                  xorbId: rep.xorbId >= 0 ? rep.xorbId : remoteXorbHashes[-rep.xorbId]
                }));
                yield event;
              }
              pendingFileEvents.length = 0;
              if (!writeChunk(xorb, chunkToCopy, chunk2.hash)) {
                throw new Error("Failed to write chunk into xorb");
              }
            }
            chunkCache.addChunkToCache(chunk2.hash, xorbId, chunkIndex, null);
          } else {
            chunkXorbId = cacheData.xorbIndex;
            chunkIndex = cacheData.chunkIndex;
            dedupedBytes += chunk2.length;
          }
          bytesSinceRemoteDedup += chunk2.length;
          chunkMetadata.push({
            xorbId: chunkXorbId,
            chunkIndex,
            length: chunk2.length
          });
          xorb.fileProgress[fileSource.path] = processedBytes / fileSource.content.size;
          if (xorb.chunks.length >= MAX_XORB_CHUNKS) {
            yield nextXorb();
            for (const event of pendingFileEvents) {
              event.representation = event.representation.map((rep) => ({
                ...rep,
                xorbId: rep.xorbId >= 0 ? rep.xorbId : remoteXorbHashes[-rep.xorbId]
              }));
              yield event;
            }
            pendingFileEvents.length = 0;
          }
        }
      };
      while (true) {
        const { done, value } = await reader.read();
        if (done) {
          yield* addChunks(chunker.finish());
          break;
        }
        processedBytes += value.length;
        sourceChunks.push(value);
        yield* addChunks(chunker.add_data(value));
      }
      const fileRepresentation = buildFileRepresentation(
        chunkMetadata,
        fileChunks,
        chunkModule.compute_verification_hash.bind(chunkModule)
      );
      xorb.immutableData = {
        chunkIndex: xorb.chunks.length,
        offset: xorb.offset
      };
      const dedupRatio = fileSource.content.size > 0 ? dedupedBytes / fileSource.content.size : 0;
      pendingFileEvents.push({
        event: "file",
        path: fileSource.path,
        hash: chunkModule.compute_file_hash(fileChunks),
        sha256: fileSource.sha256,
        dedupRatio,
        representation: fileRepresentation
      });
    }
    if (xorb.offset > 0) {
      yield xorb.event(chunkModule.compute_xorb_hash.bind(chunkModule));
    }
    for (const event of pendingFileEvents) {
      event.representation = event.representation.map((rep) => ({
        ...rep,
        xorbId: rep.xorbId >= 0 ? rep.xorbId : remoteXorbHashes[-rep.xorbId]
      }));
      yield event;
    }
  } finally {
    chunker.free();
  }
}
function backtrackDedup(xorb, computeHmac, shardData, chunkCache, chunkMetadata, dedupedBytes) {
  const chunkIndexesToBacktrackFor = /* @__PURE__ */ new Map();
  for (let chunkToRecheckIndex = xorb.immutableData?.chunkIndex ?? 0; chunkToRecheckIndex < xorb.chunks.length; chunkToRecheckIndex++) {
    const chunk2 = xorb.chunks[chunkToRecheckIndex];
    const hmacHash = computeHmac(chunk2.hash, shardData.hmacKey);
    const cacheData = chunkCache.getChunk(hmacHash, null);
    if (cacheData !== void 0) {
      chunkIndexesToBacktrackFor.set(chunkToRecheckIndex, {
        xorbId: cacheData.xorbIndex,
        chunkIndex: cacheData.chunkIndex
      });
      chunkCache.removeChunkFromCache(chunk2.hash);
    }
  }
  for (const metadata of chunkMetadata) {
    if (metadata.xorbId === xorb.id && chunkIndexesToBacktrackFor.has(metadata.chunkIndex)) {
      const backtrackData = chunkIndexesToBacktrackFor.get(metadata.chunkIndex);
      if (backtrackData !== void 0) {
        metadata.xorbId = backtrackData.xorbId;
        metadata.chunkIndex = backtrackData.chunkIndex;
        dedupedBytes += metadata.length;
      }
    }
  }
  const xorbRangesToErase = [];
  for (let i = 0; i < xorb.chunks.length; i++) {
    const chunk2 = xorb.chunks[i];
    if (chunkIndexesToBacktrackFor.has(i)) {
      xorbRangesToErase.push({
        start: chunk2.offset,
        end: i < xorb.chunks.length - 1 ? xorb.chunks[i + 1].offset : xorb.offset
      });
    }
  }
  const xorbRangesToKeep = [];
  let currentStart = 0;
  for (let i = 0; i < xorbRangesToErase.length; i++) {
    const range2 = xorbRangesToErase[i];
    if (currentStart !== range2.start) {
      xorbRangesToKeep.push({ start: currentStart, end: range2.start });
    }
    currentStart = range2.end;
  }
  if (currentStart !== xorb.offset) {
    xorbRangesToKeep.push({ start: currentStart, end: xorb.offset });
  }
  let currentOffset = 0;
  for (const range2 of xorbRangesToKeep) {
    if (range2.start !== currentOffset) {
      xorb.data.set(xorb.data.subarray(range2.start, range2.end), currentOffset);
    }
    currentOffset += range2.end - range2.start;
  }
  const newXorbChunks = [];
  const oldIndexToNewIndex = /* @__PURE__ */ new Map();
  let erasedOffset = 0;
  for (let i = 0; i < xorb.chunks.length; i++) {
    const chunk2 = xorb.chunks[i];
    if (chunkIndexesToBacktrackFor.has(i)) {
      if (i < xorb.chunks.length - 1) {
        erasedOffset += xorb.chunks[i + 1].offset - chunk2.offset;
      }
    } else {
      newXorbChunks.push({
        hash: chunk2.hash,
        length: chunk2.length,
        offset: chunk2.offset - erasedOffset
      });
      if (erasedOffset > 0) {
        oldIndexToNewIndex.set(i, newXorbChunks.length - 1);
      }
    }
  }
  xorb.chunks = newXorbChunks;
  xorb.offset = currentOffset;
  for (const chunk2 of chunkMetadata) {
    if (chunk2.xorbId === xorb.id) {
      const newIndex = oldIndexToNewIndex.get(chunk2.chunkIndex);
      if (newIndex !== void 0) {
        chunk2.chunkIndex = newIndex;
      }
    }
  }
  return dedupedBytes;
}
function writeChunk(xorb, chunk2, hash2) {
  const regularCompressedChunk = compress(chunk2);
  const bgCompressedChunk = compress(bg4_split_bytes(chunk2));
  const compressedChunk = bgCompressedChunk.length < regularCompressedChunk.length ? bgCompressedChunk : regularCompressedChunk;
  const chunkToWrite = compressedChunk.length < chunk2.length ? compressedChunk : chunk2;
  if (xorb.offset + XET_CHUNK_HEADER_BYTES + chunkToWrite.length > XORB_SIZE) {
    return false;
  }
  xorb.data[xorb.offset] = 0;
  xorb.data[xorb.offset + 1] = chunkToWrite.length & 255;
  xorb.data[xorb.offset + 2] = chunkToWrite.length >> 8 & 255;
  xorb.data[xorb.offset + 3] = chunkToWrite.length >> 16 & 255;
  xorb.data[xorb.offset + 4] = chunkToWrite.length < chunk2.length ? bgCompressedChunk.length < regularCompressedChunk.length ? 2 /* ByteGroupingLZ4 */ : 1 /* LZ4 */ : 0 /* None */;
  xorb.data[xorb.offset + 5] = chunk2.length & 255;
  xorb.data[xorb.offset + 6] = chunk2.length >> 8 & 255;
  xorb.data[xorb.offset + 7] = chunk2.length >> 16 & 255;
  xorb.data.set(chunkToWrite, xorb.offset + XET_CHUNK_HEADER_BYTES);
  xorb.chunks.push({ hash: hash2, length: chunk2.length, offset: xorb.offset });
  xorb.offset += XET_CHUNK_HEADER_BYTES + chunkToWrite.length;
  return true;
}
var buildFileRepresentation = (metadata, chunks, computeVerificationHash) => {
  if (metadata.length === 0) {
    return [];
  }
  const representation = [];
  let currentRange = {
    xorbId: metadata[0].xorbId,
    indexStart: metadata[0].chunkIndex,
    indexEnd: metadata[0].chunkIndex + 1,
    length: metadata[0].length,
    chunkHashStart: 0
  };
  for (let i = 1; i < metadata.length; i++) {
    const chunk2 = metadata[i];
    if (currentRange.xorbId === chunk2.xorbId && currentRange.indexEnd === chunk2.chunkIndex) {
      currentRange.indexEnd = chunk2.chunkIndex + 1;
      currentRange.length += chunk2.length;
    } else {
      const rangeHash2 = computeVerificationHash(chunks.slice(currentRange.chunkHashStart, i).map((x) => x.hash));
      representation.push({
        xorbId: currentRange.xorbId,
        indexStart: currentRange.indexStart,
        indexEnd: currentRange.indexEnd,
        length: currentRange.length,
        rangeHash: rangeHash2
      });
      currentRange = {
        xorbId: chunk2.xorbId,
        indexStart: chunk2.chunkIndex,
        indexEnd: chunk2.chunkIndex + 1,
        length: chunk2.length,
        chunkHashStart: i
      };
    }
  }
  const rangeHash = computeVerificationHash(chunks.slice(currentRange.chunkHashStart).map((x) => x.hash));
  representation.push({
    xorbId: currentRange.xorbId,
    indexStart: currentRange.indexStart,
    indexEnd: currentRange.indexEnd,
    length: currentRange.length,
    rangeHash
  });
  return representation;
};

// src/utils/sum.ts
function sum(arr) {
  return arr.reduce((a, b) => a + b, 0);
}

// src/utils/uploadShards.ts
var SHARD_MAX_SIZE = 64 * 1024 * 1024;
var SHARD_HEADER_SIZE = 48;
var SHARD_FOOTER_SIZE = 200;
var HASH_LENGTH2 = 32;
var XORB_FOOTER_LENGTH = 48;
var FILE_FOOTER_LENGTH = 48;
var SHARD_HEADER_VERSION = 2n;
var SHARD_FOOTER_VERSION = 1n;
var MDB_FILE_FLAG_WITH_VERIFICATION = 2147483648;
var MDB_FILE_FLAG_WITH_METADATA_EXT = 1073741824;
var SHARD_MAGIC_TAG = new Uint8Array([
  "H".charCodeAt(0),
  "F".charCodeAt(0),
  "R".charCodeAt(0),
  "e".charCodeAt(0),
  "p".charCodeAt(0),
  "o".charCodeAt(0),
  "M".charCodeAt(0),
  "e".charCodeAt(0),
  "t".charCodeAt(0),
  "a".charCodeAt(0),
  "D".charCodeAt(0),
  "a".charCodeAt(0),
  "t".charCodeAt(0),
  "a".charCodeAt(0),
  0,
  85,
  105,
  103,
  69,
  106,
  123,
  129,
  87,
  131,
  165,
  189,
  217,
  92,
  205,
  209,
  74,
  169
]);
async function* uploadShards(source, params) {
  const xorbHashes = [];
  const fileInfoSection = new Uint8Array(Math.floor(SHARD_MAX_SIZE - SHARD_HEADER_SIZE - SHARD_FOOTER_SIZE) * 0.25);
  const xorbInfoSection = new Uint8Array(Math.floor(SHARD_MAX_SIZE - SHARD_HEADER_SIZE - SHARD_FOOTER_SIZE) * 0.75);
  const xorbView = new DataView(xorbInfoSection.buffer);
  let xorbViewOffset = 0;
  const fileInfoView = new DataView(fileInfoSection.buffer);
  let fileViewOffset = 0;
  let xorbTotalSize = 0n;
  let fileTotalSize = 0n;
  let xorbTotalUnpackedSize = 0n;
  for await (const output of createXorbs(source, params)) {
    switch (output.event) {
      case "xorb": {
        xorbHashes.push(output.hash);
        const xorbEntrySize = HASH_LENGTH2 + 4 + 4 + 4 + 4;
        const chunksSize = output.chunks.length * (HASH_LENGTH2 + 4 + 4 + 8);
        const totalXorbSize = xorbEntrySize + chunksSize;
        if (xorbViewOffset + totalXorbSize > xorbInfoSection.length) {
          if (xorbViewOffset > 0 || fileViewOffset > 0) {
            await uploadShard(createShard(), params);
          }
        }
        writeHashToArray(output.hash, xorbInfoSection, xorbViewOffset);
        xorbViewOffset += HASH_LENGTH2;
        xorbView.setUint32(xorbViewOffset, 0, true);
        xorbViewOffset += 4;
        xorbView.setUint32(xorbViewOffset, output.chunks.length, true);
        xorbViewOffset += 4;
        const xorbUnpackedSize = sum(output.chunks.map((x) => x.length));
        xorbView.setUint32(xorbViewOffset, xorbUnpackedSize, true);
        xorbTotalUnpackedSize += BigInt(xorbUnpackedSize);
        xorbTotalSize += BigInt(output.xorb.byteLength);
        xorbViewOffset += 4;
        xorbView.setUint32(xorbViewOffset, output.xorb.byteLength, true);
        xorbViewOffset += 4;
        let chunkBytes = 0;
        for (const chunk2 of output.chunks) {
          writeHashToArray(chunk2.hash, xorbInfoSection, xorbViewOffset);
          xorbViewOffset += HASH_LENGTH2;
          xorbView.setUint32(xorbViewOffset, chunkBytes, true);
          xorbViewOffset += 4;
          xorbView.setUint32(xorbViewOffset, chunk2.length, true);
          xorbViewOffset += 4;
          xorbView.setBigUint64(xorbViewOffset, 0n, true);
          xorbViewOffset += 8;
          chunkBytes += chunk2.length;
        }
        await uploadXorb(output, params);
        for (const file of output.files) {
          yield { event: "fileProgress", path: file.path, progress: file.progress };
        }
        break;
      }
      case "file": {
        yield { event: "file", path: output.path, sha256: output.sha256, dedupRatio: output.dedupRatio };
        const fileHeaderSize = HASH_LENGTH2 + 4 + 4 + 8;
        const representationSize = output.representation.length * (HASH_LENGTH2 + 4 + 4 + 4 + 4);
        const verificationSize = output.representation.length * (HASH_LENGTH2 + 16);
        const metadataSize = HASH_LENGTH2 + 16;
        const totalFileSize = fileHeaderSize + representationSize + verificationSize + metadataSize;
        if (fileViewOffset + totalFileSize > fileInfoSection.length) {
          if (xorbViewOffset > 0 || fileViewOffset > 0) {
            await uploadShard(createShard(), params);
          }
        }
        writeHashToArray(output.hash, fileInfoSection, fileViewOffset);
        fileViewOffset += HASH_LENGTH2;
        fileInfoView.setUint32(fileViewOffset, MDB_FILE_FLAG_WITH_METADATA_EXT + MDB_FILE_FLAG_WITH_VERIFICATION, true);
        fileViewOffset += 4;
        fileInfoView.setUint32(fileViewOffset, output.representation.length, true);
        fileViewOffset += 4;
        fileInfoView.setBigUint64(fileViewOffset, 0n, true);
        fileViewOffset += 8;
        for (const repItem of output.representation) {
          writeHashToArray(
            typeof repItem.xorbId === "number" ? xorbHashes[repItem.xorbId] : repItem.xorbId,
            fileInfoSection,
            fileViewOffset
          );
          fileViewOffset += HASH_LENGTH2;
          fileInfoView.setUint32(fileViewOffset, 0, true);
          fileViewOffset += 4;
          fileInfoView.setUint32(fileViewOffset, repItem.length, true);
          fileViewOffset += 4;
          fileInfoView.setUint32(fileViewOffset, repItem.indexStart, true);
          fileViewOffset += 4;
          fileInfoView.setUint32(fileViewOffset, repItem.indexEnd, true);
          fileViewOffset += 4;
        }
        for (const repItem of output.representation) {
          writeHashToArray(repItem.rangeHash, fileInfoSection, fileViewOffset);
          fileViewOffset += HASH_LENGTH2;
          for (let i = 0; i < 16; i++) {
            fileInfoSection[fileViewOffset + i] = 0;
          }
          fileViewOffset += 16;
        }
        writeHashToArray(output.sha256, fileInfoSection, fileViewOffset);
        fileViewOffset += HASH_LENGTH2;
        for (let i = 0; i < 16; i++) {
          fileInfoSection[fileViewOffset + i] = 0;
        }
        fileViewOffset += 16;
        break;
      }
    }
  }
  function createShard() {
    const shard = new Uint8Array(
      SHARD_HEADER_SIZE + SHARD_FOOTER_SIZE + xorbViewOffset + XORB_FOOTER_LENGTH + fileViewOffset + FILE_FOOTER_LENGTH
    );
    const shardView = new DataView(shard.buffer);
    let shardOffset = 0;
    shard.set(SHARD_MAGIC_TAG, shardOffset);
    shardOffset += SHARD_MAGIC_TAG.length;
    shardView.setBigUint64(shardOffset, SHARD_HEADER_VERSION, true);
    shardOffset += 8;
    shardView.setBigUint64(shardOffset, BigInt(SHARD_FOOTER_SIZE), true);
    shardOffset += 8;
    shard.set(fileInfoSection.slice(0, fileViewOffset), shardOffset);
    shardOffset += fileViewOffset;
    for (let i = 0; i < 32; i++) {
      shard[shardOffset + i] = 255;
    }
    shardOffset += 32;
    for (let i = 0; i < 16; i++) {
      shard[shardOffset + i] = 0;
    }
    shardOffset += 16;
    const xorbInfoOffset = shardOffset;
    shard.set(xorbInfoSection.slice(0, xorbViewOffset), shardOffset);
    shardOffset += xorbViewOffset;
    for (let i = 0; i < 32; i++) {
      shard[shardOffset + i] = 255;
    }
    shardOffset += 32;
    for (let i = 0; i < 16; i++) {
      shard[shardOffset + i] = 0;
    }
    shardOffset += 16;
    const footerOffset = shardOffset;
    shardView.setBigUint64(shardOffset, SHARD_FOOTER_VERSION, true);
    shardOffset += 8;
    shardView.setBigUint64(shardOffset, BigInt(SHARD_HEADER_SIZE), true);
    shardOffset += 8;
    shardView.setBigUint64(shardOffset, BigInt(xorbInfoOffset), true);
    shardOffset += 8;
    for (let i = 0; i < 48; i++) {
      shardView.setUint8(shardOffset + i, 0);
    }
    shardOffset += 48;
    for (let i = 0; i < 32; i++) {
      shardView.setUint8(shardOffset + i, 0);
    }
    shardOffset += 32;
    shardView.setBigUint64(shardOffset, BigInt(Math.floor(Date.now() / 1e3)), true);
    shardOffset += 8;
    shardView.setBigUint64(shardOffset, 0n, true);
    shardOffset += 8;
    for (let i = 0; i < 48; i++) {
      shardView.setUint8(shardOffset + i, 0);
    }
    shardOffset += 48;
    shardView.setBigUint64(shardOffset, xorbTotalSize, true);
    shardOffset += 8;
    shardView.setBigUint64(shardOffset, fileTotalSize, true);
    shardOffset += 8;
    shardView.setBigUint64(shardOffset, xorbTotalUnpackedSize, true);
    shardOffset += 8;
    shardView.setBigUint64(shardOffset, BigInt(footerOffset), true);
    xorbViewOffset = 0;
    fileViewOffset = 0;
    xorbTotalSize = 0n;
    xorbTotalUnpackedSize = 0n;
    fileTotalSize = 0n;
    return shard;
  }
  if (xorbViewOffset || fileViewOffset) {
    await uploadShard(createShard(), params);
  }
}
function writeHashToArray(hash2, array, offset) {
  for (let i = 0; i < hash2.length; i += 16) {
    array[offset + i / 2] = parseInt(hash2.substring(i + 2 * 7, i + 2 * 8), 16);
    array[offset + i / 2 + 1] = parseInt(hash2.substring(i + 2 * 6, i + 2 * 7), 16);
    array[offset + i / 2 + 2] = parseInt(hash2.substring(i + 2 * 5, i + 2 * 6), 16);
    array[offset + i / 2 + 3] = parseInt(hash2.substring(i + 2 * 4, i + 2 * 5), 16);
    array[offset + i / 2 + 4] = parseInt(hash2.substring(i + 2 * 3, i + 2 * 4), 16);
    array[offset + i / 2 + 5] = parseInt(hash2.substring(i + 2 * 2, i + 2 * 3), 16);
    array[offset + i / 2 + 6] = parseInt(hash2.substring(i + 2 * 1, i + 2 * 2), 16);
    array[offset + i / 2 + 7] = parseInt(hash2.substring(i + 2 * 0, i + 2 * 1), 16);
  }
}
async function uploadXorb(xorb, params) {
  const token = await xetWriteToken(params);
  const resp = await params.customFetch(`${token.casUrl}/v1/xorb/default/${xorb.hash}`, {
    method: "POST",
    body: xorb.xorb,
    headers: {
      Authorization: `Bearer ${token.accessToken}`
    }
  });
  if (!resp.ok) {
    throw await createApiError(resp);
  }
}
async function uploadShard(shard, params) {
  const token = await xetWriteToken(params);
  const resp = await params.customFetch(`${token.casUrl}/v1/shard`, {
    method: "POST",
    body: shard,
    headers: {
      Authorization: `Bearer ${token.accessToken}`
    }
  });
  if (!resp.ok) {
    throw await createApiError(resp);
  }
}

// src/lib/commit.ts
var CONCURRENT_SHAS = 5;
var CONCURRENT_LFS_UPLOADS = 5;
var MULTIPART_PARALLEL_UPLOAD = 5;
function isFileOperation(op) {
  const ret = op.operation === "addOrUpdate";
  if (ret && !(op.content instanceof Blob)) {
    throw new TypeError("Precondition failed: op.content should be a Blob");
  }
  return ret;
}
async function* commitIter(params) {
  const accessToken = checkCredentials(params);
  const repoId = toRepoId(params.repo);
  yield { event: "phase", phase: "preuploading" };
  const lfsShas = /* @__PURE__ */ new Map();
  const abortController = new AbortController();
  const abortSignal = abortController.signal;
  if (!abortSignal.throwIfAborted) {
    abortSignal.throwIfAborted = () => {
      if (abortSignal.aborted) {
        throw new DOMException("Aborted", "AbortError");
      }
    };
  }
  if (params.abortSignal) {
    params.abortSignal.addEventListener("abort", () => abortController.abort());
  }
  try {
    const allOperations = (await Promise.all(
      params.operations.map(async (operation) => {
        if (operation.operation !== "addOrUpdate") {
          return operation;
        }
        if (!(operation.content instanceof URL)) {
          return { ...operation, content: operation.content };
        }
        const lazyBlobs = await createBlobs(operation.content, operation.path, {
          fetch: params.fetch,
          maxFolderDepth: params.maxFolderDepth
        });
        abortSignal?.throwIfAborted();
        return lazyBlobs.map((blob) => ({
          ...operation,
          content: blob.blob,
          path: blob.path
        }));
      })
    )).flat(1);
    const gitAttributes = allOperations.filter(isFileOperation).find((op) => op.path === ".gitattributes")?.content;
    for (const operations of chunk(allOperations.filter(isFileOperation), 100)) {
      const payload = {
        gitAttributes: gitAttributes && await gitAttributes.text(),
        files: await Promise.all(
          operations.map(async (operation) => ({
            path: operation.path,
            size: operation.content.size,
            sample: base64FromBytes(new Uint8Array(await operation.content.slice(0, 512).arrayBuffer()))
          }))
        )
      };
      abortSignal?.throwIfAborted();
      const res = await (params.fetch ?? fetch)(
        `${params.hubUrl ?? HUB_URL}/api/${repoId.type}s/${repoId.name}/preupload/${encodeURIComponent(
          params.branch ?? "main"
        )}` + (params.isPullRequest ? "?create_pr=1" : ""),
        {
          method: "POST",
          headers: {
            ...accessToken && { Authorization: `Bearer ${accessToken}` },
            "Content-Type": "application/json"
          },
          body: JSON.stringify(payload),
          signal: abortSignal
        }
      );
      if (!res.ok) {
        throw await createApiError(res);
      }
      const json = await res.json();
      for (const file of json.files) {
        if (file.uploadMode === "lfs") {
          lfsShas.set(file.path, null);
        }
      }
    }
    yield { event: "phase", phase: "uploadingLargeFiles" };
    for (const operations of chunk(
      allOperations.filter(isFileOperation).filter((op) => lfsShas.has(op.path)),
      100
    )) {
      const shas = yield* eventToGenerator((yieldCallback, returnCallback, rejectCallack) => {
        return promisesQueue(
          operations.map((op) => async () => {
            const iterator = sha256(op.content, { useWebWorker: params.useWebWorkers, abortSignal });
            let res2;
            do {
              res2 = await iterator.next();
              if (!res2.done) {
                yieldCallback({ event: "fileProgress", path: op.path, progress: res2.value, state: "hashing" });
              }
            } while (!res2.done);
            const sha = res2.value;
            lfsShas.set(op.path, res2.value);
            return sha;
          }),
          CONCURRENT_SHAS
        ).then(returnCallback, rejectCallack);
      });
      abortSignal?.throwIfAborted();
      const payload = {
        operation: "upload",
        // multipart is a custom protocol for HF
        transfers: ["basic", "multipart"],
        hash_algo: "sha_256",
        ...!params.isPullRequest && {
          ref: {
            name: params.branch ?? "main"
          }
        },
        objects: operations.map((op, i) => ({
          oid: shas[i],
          size: op.content.size
        }))
      };
      const res = await (params.fetch ?? fetch)(
        `${params.hubUrl ?? HUB_URL}/${repoId.type === "model" ? "" : repoId.type + "s/"}${repoId.name}.git/info/lfs/objects/batch`,
        {
          method: "POST",
          headers: {
            ...accessToken && { Authorization: `Bearer ${accessToken}` },
            Accept: "application/vnd.git-lfs+json",
            "Content-Type": "application/vnd.git-lfs+json"
          },
          body: JSON.stringify(payload),
          signal: abortSignal
        }
      );
      if (!res.ok) {
        throw await createApiError(res);
      }
      const json = await res.json();
      const batchRequestId = res.headers.get("X-Request-Id") || void 0;
      const shaToOperation = new Map(operations.map((op, i) => [shas[i], op]));
      if (params.useXet) {
        for (const obj of json.objects) {
          const op = shaToOperation.get(obj.oid);
          if (!op) {
            throw new InvalidApiResponseFormatError("Unrequested object ID in response");
          }
          if (obj.error) {
            const errorMessage = `Error while doing LFS batch call for ${operations[shas.indexOf(obj.oid)].path}: ${obj.error.message}${batchRequestId ? ` - Request ID: ${batchRequestId}` : ""}`;
            throw new HubApiError(res.url, obj.error.code, batchRequestId, errorMessage);
          }
          if (!obj.actions?.upload) {
            yield {
              event: "fileProgress",
              path: op.path,
              progress: 1,
              state: "uploading"
            };
          }
        }
        for await (const event of uploadShards(
          async function* () {
            for (const obj of json.objects) {
              const op = shaToOperation.get(obj.oid);
              if (!op || !obj.actions?.upload) {
                continue;
              }
              abortSignal?.throwIfAborted();
              yield { content: op.content, path: op.path, sha256: obj.oid };
            }
          }(),
          {
            customFetch: params.fetch ?? fetch,
            accessToken,
            hubUrl: params.hubUrl ?? HUB_URL,
            repo: repoId,
            // todo: maybe leave empty if PR?
            rev: params.branch ?? "main"
          }
        )) {
          if (event.event === "file") {
            yield {
              event: "fileProgress",
              path: event.path,
              progress: 1,
              state: "uploading"
            };
          } else if (event.event === "fileProgress") {
            yield {
              event: "fileProgress",
              path: event.path,
              progress: event.progress,
              state: "uploading"
            };
          }
        }
      } else {
        yield* eventToGenerator((yieldCallback, returnCallback, rejectCallback) => {
          return promisesQueueStreaming(
            json.objects.map((obj) => async () => {
              const op = shaToOperation.get(obj.oid);
              if (!op) {
                throw new InvalidApiResponseFormatError("Unrequested object ID in response");
              }
              abortSignal?.throwIfAborted();
              if (obj.error) {
                const errorMessage = `Error while doing LFS batch call for ${operations[shas.indexOf(obj.oid)].path}: ${obj.error.message}${batchRequestId ? ` - Request ID: ${batchRequestId}` : ""}`;
                throw new HubApiError(res.url, obj.error.code, batchRequestId, errorMessage);
              }
              if (!obj.actions?.upload) {
                yieldCallback({
                  event: "fileProgress",
                  path: op.path,
                  progress: 1,
                  state: "uploading"
                });
                return;
              }
              yieldCallback({
                event: "fileProgress",
                path: op.path,
                progress: 0,
                state: "uploading"
              });
              const content = op.content;
              const header = obj.actions.upload.header;
              if (header?.chunk_size) {
                const chunkSize = parseInt(header.chunk_size);
                const completionUrl = obj.actions.upload.href;
                const parts = Object.keys(header).filter((key) => /^[0-9]+$/.test(key));
                if (parts.length !== Math.ceil(content.size / chunkSize)) {
                  throw new Error("Invalid server response to upload large LFS file, wrong number of parts");
                }
                const completeReq = {
                  oid: obj.oid,
                  parts: parts.map((part) => ({
                    partNumber: +part,
                    etag: ""
                  }))
                };
                const progressCallback = (progress) => yieldCallback({ event: "fileProgress", path: op.path, progress, state: "uploading" });
                await promisesQueueStreaming(
                  parts.map((part) => async () => {
                    abortSignal?.throwIfAborted();
                    const index = parseInt(part) - 1;
                    const slice = content.slice(index * chunkSize, (index + 1) * chunkSize);
                    const res3 = await (params.fetch ?? fetch)(header[part], {
                      method: "PUT",
                      /** Unfortunately, browsers don't support our inherited version of Blob in fetch calls */
                      body: slice instanceof WebBlob && isFrontend ? await slice.arrayBuffer() : slice,
                      signal: abortSignal,
                      ...{
                        progressHint: {
                          path: op.path,
                          part: index,
                          numParts: parts.length,
                          progressCallback
                        }
                        // eslint-disable-next-line @typescript-eslint/no-explicit-any
                      }
                    });
                    if (!res3.ok) {
                      throw await createApiError(res3, {
                        requestId: batchRequestId,
                        message: `Error while uploading part ${part} of ${operations[shas.indexOf(obj.oid)].path} to LFS storage`
                      });
                    }
                    const eTag = res3.headers.get("ETag");
                    if (!eTag) {
                      throw new Error("Cannot get ETag of part during multipart upload");
                    }
                    completeReq.parts[Number(part) - 1].etag = eTag;
                  }),
                  MULTIPART_PARALLEL_UPLOAD
                );
                abortSignal?.throwIfAborted();
                const res2 = await (params.fetch ?? fetch)(completionUrl, {
                  method: "POST",
                  body: JSON.stringify(completeReq),
                  headers: {
                    Accept: "application/vnd.git-lfs+json",
                    "Content-Type": "application/vnd.git-lfs+json"
                  },
                  signal: abortSignal
                });
                if (!res2.ok) {
                  throw await createApiError(res2, {
                    requestId: batchRequestId,
                    message: `Error completing multipart upload of ${operations[shas.indexOf(obj.oid)].path} to LFS storage`
                  });
                }
                yieldCallback({
                  event: "fileProgress",
                  path: op.path,
                  progress: 1,
                  state: "uploading"
                });
              } else {
                const res2 = await (params.fetch ?? fetch)(obj.actions.upload.href, {
                  method: "PUT",
                  headers: {
                    ...batchRequestId ? { "X-Request-Id": batchRequestId } : void 0
                  },
                  /** Unfortunately, browsers don't support our inherited version of Blob in fetch calls */
                  body: content instanceof WebBlob && isFrontend ? await content.arrayBuffer() : content,
                  signal: abortSignal,
                  ...{
                    progressHint: {
                      path: op.path,
                      progressCallback: (progress) => yieldCallback({
                        event: "fileProgress",
                        path: op.path,
                        progress,
                        state: "uploading"
                      })
                    }
                    // eslint-disable-next-line @typescript-eslint/no-explicit-any
                  }
                });
                if (!res2.ok) {
                  throw await createApiError(res2, {
                    requestId: batchRequestId,
                    message: `Error while uploading ${operations[shas.indexOf(obj.oid)].path} to LFS storage`
                  });
                }
                yieldCallback({
                  event: "fileProgress",
                  path: op.path,
                  progress: 1,
                  state: "uploading"
                });
              }
            }),
            CONCURRENT_LFS_UPLOADS
          ).then(returnCallback, rejectCallback);
        });
      }
    }
    abortSignal?.throwIfAborted();
    yield { event: "phase", phase: "committing" };
    return yield* eventToGenerator(
      async (yieldCallback, returnCallback, rejectCallback) => (params.fetch ?? fetch)(
        `${params.hubUrl ?? HUB_URL}/api/${repoId.type}s/${repoId.name}/commit/${encodeURIComponent(
          params.branch ?? "main"
        )}` + (params.isPullRequest ? "?create_pr=1" : ""),
        {
          method: "POST",
          headers: {
            ...accessToken && { Authorization: `Bearer ${accessToken}` },
            "Content-Type": "application/x-ndjson"
          },
          body: [
            {
              key: "header",
              value: {
                summary: params.title,
                description: params.description,
                parentCommit: params.parentCommit
              }
            },
            ...await Promise.all(
              allOperations.map((operation) => {
                if (isFileOperation(operation)) {
                  const sha = lfsShas.get(operation.path);
                  if (sha) {
                    return {
                      key: "lfsFile",
                      value: {
                        path: operation.path,
                        algo: "sha256",
                        size: operation.content.size,
                        oid: sha
                      }
                    };
                  }
                }
                return convertOperationToNdJson(operation);
              })
            )
          ].map((x) => JSON.stringify(x)).join("\n"),
          signal: abortSignal,
          ...{
            progressHint: {
              progressCallback: (progress) => {
                for (const op of allOperations) {
                  if (isFileOperation(op) && !lfsShas.has(op.path)) {
                    yieldCallback({
                      event: "fileProgress",
                      path: op.path,
                      progress,
                      state: "uploading"
                    });
                  }
                }
              }
            }
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
          }
        }
      ).then(async (res) => {
        if (!res.ok) {
          throw await createApiError(res);
        }
        const json = await res.json();
        returnCallback({
          pullRequestUrl: json.pullRequestUrl,
          commit: {
            oid: json.commitOid,
            url: json.commitUrl
          },
          hookOutput: json.hookOutput
        });
      }).catch(rejectCallback)
    );
  } catch (err) {
    abortController.abort();
    throw err;
  }
}
async function commit(params) {
  const iterator = commitIter(params);
  let res = await iterator.next();
  while (!res.done) {
    res = await iterator.next();
  }
  return res.value;
}
async function convertOperationToNdJson(operation) {
  switch (operation.operation) {
    case "addOrUpdate": {
      return {
        key: "file",
        value: {
          content: base64FromBytes(new Uint8Array(await operation.content.arrayBuffer())),
          path: operation.path,
          encoding: "base64"
        }
      };
    }
    case "delete": {
      return {
        key: "deletedFile",
        value: {
          path: operation.path
        }
      };
    }
    default:
      throw new TypeError("Unknown operation: " + operation.operation);
  }
}

// src/lib/count-commits.ts
async function countCommits(params) {
  const accessToken = checkCredentials(params);
  const repoId = toRepoId(params.repo);
  const url = `${params.hubUrl ?? HUB_URL}/api/${repoId.type}s/${repoId.name}/commits/${params.revision ?? "main"}?limit=1`;
  const res = await (params.fetch ?? fetch)(url, {
    headers: accessToken ? { Authorization: `Bearer ${accessToken}` } : {}
  });
  if (!res.ok) {
    throw await createApiError(res);
  }
  return parseInt(res.headers.get("x-total-count") ?? "0", 10);
}

// src/lib/create-repo.ts
async function createRepo(params) {
  const accessToken = checkCredentials(params);
  const repoId = toRepoId(params.repo);
  const [namespace, repoName] = repoId.name.split("/");
  if (!namespace || !repoName) {
    throw new TypeError(
      `"${repoId.name}" is not a fully qualified repo name. It should be of the form "{namespace}/{repoName}".`
    );
  }
  const res = await (params.fetch ?? fetch)(`${params.hubUrl ?? HUB_URL}/api/repos/create`, {
    method: "POST",
    body: JSON.stringify({
      name: repoName,
      private: params.private,
      organization: namespace,
      license: params.license,
      ...repoId.type === "space" ? {
        type: "space",
        sdk: params.sdk ?? "static"
      } : {
        type: repoId.type
      },
      files: params.files ? await Promise.all(
        params.files.map(async (file) => ({
          encoding: "base64",
          path: file.path,
          content: base64FromBytes(
            new Uint8Array(file.content instanceof Blob ? await file.content.arrayBuffer() : file.content)
          )
        }))
      ) : void 0
    }),
    headers: {
      Authorization: `Bearer ${accessToken}`,
      "Content-Type": "application/json"
    }
  });
  if (!res.ok) {
    throw await createApiError(res);
  }
  const output = await res.json();
  return { repoUrl: output.url };
}

// src/lib/create-branch.ts
async function createBranch(params) {
  const repoId = toRepoId(params.repo);
  const res = await (params.fetch ?? fetch)(
    `${params.hubUrl ?? HUB_URL}/api/${repoId.type}s/${repoId.name}/branch/${encodeURIComponent(params.branch)}`,
    {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        ...params.accessToken && {
          Authorization: `Bearer ${params.accessToken}`
        }
      },
      body: JSON.stringify({
        startingPoint: params.revision,
        ...params.empty && { emptyBranch: true },
        overwrite: params.overwrite
      })
    }
  );
  if (!res.ok) {
    throw await createApiError(res);
  }
}

// src/lib/create-collection.ts
async function createCollection(params) {
  const accessToken = checkCredentials(params);
  const res = await (params.fetch ?? fetch)(`${params.hubUrl ?? HUB_URL}/api/collections`, {
    method: "POST",
    body: JSON.stringify(params.collection),
    headers: {
      Authorization: `Bearer ${accessToken}`,
      "Content-Type": "application/json"
    }
  });
  if (!res.ok) {
    throw await createApiError(res);
  }
  const output = await res.json();
  return { slug: output.slug };
}

// src/utils/pick.ts
function pick(o, props) {
  return Object.assign(
    {},
    ...props.map((prop) => {
      if (o[prop] !== void 0) {
        return { [prop]: o[prop] };
      }
    })
  );
}

// src/utils/parseLinkHeader.ts
function parseLinkHeader(header) {
  const regex = /<(https?:[/][/][^>]+)>;\s+rel="([^"]+)"/g;
  return Object.fromEntries([...header.matchAll(regex)].map(([, url, rel]) => [rel, url]));
}

// src/lib/list-datasets.ts
var DATASET_EXPAND_KEYS = [
  "private",
  "downloads",
  "gated",
  "likes",
  "lastModified"
];
var DATASET_EXPANDABLE_KEYS = [
  "author",
  "cardData",
  "citation",
  "createdAt",
  "disabled",
  "description",
  "downloads",
  "downloadsAllTime",
  "gated",
  "gitalyUid",
  "lastModified",
  "likes",
  "paperswithcode_id",
  "private",
  // "siblings",
  "sha",
  "tags"
];
async function* listDatasets(params) {
  const accessToken = params && checkCredentials(params);
  let totalToFetch = params?.limit ?? Infinity;
  const search = new URLSearchParams([
    ...Object.entries({
      limit: String(Math.min(totalToFetch, 500)),
      ...params?.search?.owner ? { author: params.search.owner } : void 0,
      ...params?.search?.query ? { search: params.search.query } : void 0
    }),
    ...params?.search?.tags?.map((tag) => ["filter", tag]) ?? [],
    ...DATASET_EXPAND_KEYS.map((val) => ["expand", val]),
    ...params?.additionalFields?.map((val) => ["expand", val]) ?? []
  ]).toString();
  let url = `${params?.hubUrl || HUB_URL}/api/datasets` + (search ? "?" + search : "");
  while (url) {
    const res = await (params?.fetch ?? fetch)(url, {
      headers: {
        accept: "application/json",
        ...accessToken ? { Authorization: `Bearer ${accessToken}` } : void 0
      }
    });
    if (!res.ok) {
      throw await createApiError(res);
    }
    const items = await res.json();
    for (const item of items) {
      yield {
        ...params?.additionalFields && pick(item, params.additionalFields),
        id: item._id,
        name: item.id,
        private: item.private,
        downloads: item.downloads,
        likes: item.likes,
        gated: item.gated,
        updatedAt: new Date(item.lastModified)
      };
      totalToFetch--;
      if (totalToFetch <= 0) {
        return;
      }
    }
    const linkHeader = res.headers.get("Link");
    url = linkHeader ? parseLinkHeader(linkHeader).next : void 0;
  }
}

// src/lib/dataset-info.ts
async function datasetInfo(params) {
  const accessToken = params && checkCredentials(params);
  const search = new URLSearchParams([
    ...DATASET_EXPAND_KEYS.map((val) => ["expand", val]),
    ...params?.additionalFields?.map((val) => ["expand", val]) ?? []
  ]).toString();
  const response = await (params.fetch || fetch)(
    `${params?.hubUrl || HUB_URL}/api/datasets/${params.name}/revision/${encodeURIComponent(
      params.revision ?? "HEAD"
    )}?${search.toString()}`,
    {
      headers: {
        ...accessToken ? { Authorization: `Bearer ${accessToken}` } : {},
        Accepts: "application/json"
      }
    }
  );
  if (!response.ok) {
    throw await createApiError(response);
  }
  const data = await response.json();
  return {
    ...params?.additionalFields && pick(data, params.additionalFields),
    id: data._id,
    name: data.id,
    private: data.private,
    downloads: data.downloads,
    likes: data.likes,
    gated: data.gated,
    updatedAt: new Date(data.lastModified)
  };
}

// src/lib/delete-branch.ts
async function deleteBranch(params) {
  const repoId = toRepoId(params.repo);
  const res = await (params.fetch ?? fetch)(
    `${params.hubUrl ?? HUB_URL}/api/${repoId.type}s/${repoId.name}/branch/${encodeURIComponent(params.branch)}`,
    {
      method: "DELETE",
      headers: {
        ...params.accessToken && {
          Authorization: `Bearer ${params.accessToken}`
        }
      }
    }
  );
  if (!res.ok) {
    throw await createApiError(res);
  }
}

// src/lib/delete-file.ts
function deleteFile(params) {
  return commit({
    ...params.accessToken ? { accessToken: params.accessToken } : { credentials: params.credentials },
    repo: params.repo,
    operations: [
      {
        operation: "delete",
        path: params.path
      }
    ],
    title: params.commitTitle ?? `Delete ${params.path}`,
    description: params.commitDescription,
    hubUrl: params.hubUrl,
    branch: params.branch,
    isPullRequest: params.isPullRequest,
    parentCommit: params.parentCommit,
    fetch: params.fetch
  });
}

// src/lib/delete-files.ts
function deleteFiles(params) {
  return commit({
    ...params.accessToken ? { accessToken: params.accessToken } : { credentials: params.credentials },
    repo: params.repo,
    operations: params.paths.map((path2) => ({
      operation: "delete",
      path: path2
    })),
    title: params.commitTitle ?? `Deletes ${params.paths.length} files`,
    description: params.commitDescription,
    hubUrl: params.hubUrl,
    branch: params.branch,
    isPullRequest: params.isPullRequest,
    parentCommit: params.parentCommit,
    fetch: params.fetch
  });
}

// src/lib/delete-repo.ts
async function deleteRepo(params) {
  const accessToken = checkCredentials(params);
  const repoId = toRepoId(params.repo);
  const [namespace, repoName] = repoId.name.split("/");
  const res = await (params.fetch ?? fetch)(`${params.hubUrl ?? HUB_URL}/api/repos/delete`, {
    method: "DELETE",
    body: JSON.stringify({
      name: repoName,
      organization: namespace,
      type: repoId.type
    }),
    headers: {
      Authorization: `Bearer ${accessToken}`,
      "Content-Type": "application/json"
    }
  });
  if (!res.ok) {
    throw await createApiError(res);
  }
}

// src/lib/delete-collection.ts
async function deleteCollection(params) {
  const accessToken = checkCredentials(params);
  const res = await (params.fetch ?? fetch)(`${params.hubUrl ?? HUB_URL}/api/collections/${params.slug}`, {
    method: "DELETE",
    headers: {
      Authorization: `Bearer ${accessToken}`,
      "Content-Type": "application/json"
    }
  });
  if (!res.ok) {
    throw await createApiError(res);
  }
}

// src/lib/file-download-info.ts
async function fileDownloadInfo(params) {
  const accessToken = checkCredentials(params);
  const repoId = toRepoId(params.repo);
  const hubUrl = params.hubUrl ?? HUB_URL;
  const url = `${hubUrl}/${repoId.type === "model" ? "" : `${repoId.type}s/`}${repoId.name}/${params.raw ? "raw" : "resolve"}/${encodeURIComponent(params.revision ?? "main")}/${params.path}` + (params.noContentDisposition ? "?noContentDisposition=1" : "");
  const resp = await (params.fetch ?? fetch)(url, {
    method: "GET",
    headers: {
      ...accessToken && {
        Authorization: `Bearer ${accessToken}`
      },
      Range: "bytes=0-0",
      Accept: "application/vnd.xet-fileinfo+json, */*"
    }
  });
  if (resp.status === 404 && resp.headers.get("X-Error-Code") === "EntryNotFound") {
    return null;
  }
  if (!resp.ok) {
    throw await createApiError(resp);
  }
  let size;
  let xetInfo;
  if (resp.headers.get("Content-Type")?.includes("application/vnd.xet-fileinfo+json")) {
    size = parseInt(resp.headers.get("X-Linked-Size") ?? "invalid");
    if (isNaN(size)) {
      throw new InvalidApiResponseFormatError("Invalid file size received in X-Linked-Size header");
    }
    const hash2 = resp.headers.get("X-Xet-Hash");
    const links = parseLinkHeader(resp.headers.get("Link") ?? "");
    const reconstructionUrl = (() => {
      try {
        return new URL(links["xet-reconstruction-info"]);
      } catch {
        return null;
      }
    })();
    const refreshUrl = (() => {
      try {
        return new URL(links["xet-auth"]);
      } catch {
        return null;
      }
    })();
    if (!hash2) {
      throw new InvalidApiResponseFormatError("No hash received in X-Xet-Hash header");
    }
    if (!reconstructionUrl || !refreshUrl) {
      throw new InvalidApiResponseFormatError("No xet-reconstruction-info or xet-auth link header");
    }
    xetInfo = {
      hash: hash2,
      refreshUrl,
      reconstructionUrl
    };
  }
  if (size === void 0 || isNaN(size)) {
    const contentRangeHeader = resp.headers.get("content-range");
    if (!contentRangeHeader) {
      throw new InvalidApiResponseFormatError("Expected size information");
    }
    const [, parsedSize] = contentRangeHeader.split("/");
    size = parseInt(parsedSize);
    if (isNaN(size)) {
      throw new InvalidApiResponseFormatError("Invalid file size received");
    }
  }
  const etag = resp.headers.get("X-Linked-ETag") ?? resp.headers.get("ETag") ?? void 0;
  if (!etag) {
    throw new InvalidApiResponseFormatError("Expected ETag");
  }
  return {
    etag,
    size,
    xet: xetInfo,
    // Cannot use resp.url in case it's a S3 url and the user adds an Authorization header to it.
    url: resp.url && (new URL(resp.url).origin === new URL(hubUrl).origin || resp.headers.get("X-Cache")?.endsWith(" cloudfront")) ? resp.url : url
  };
}

// src/lib/download-file.ts
async function downloadFile(params) {
  const accessToken = checkCredentials(params);
  const info = params.downloadInfo ?? await fileDownloadInfo({
    accessToken,
    repo: params.repo,
    path: params.path,
    revision: params.revision,
    hubUrl: params.hubUrl,
    fetch: params.fetch,
    raw: params.raw
  });
  if (!info) {
    return null;
  }
  if (info.xet && params.xet) {
    return new XetBlob({
      refreshUrl: info.xet.refreshUrl.href,
      reconstructionUrl: info.xet.reconstructionUrl.href,
      fetch: params.fetch,
      accessToken,
      size: info.size
    });
  }
  return new WebBlob(new URL(info.url), 0, info.size, "", true, params.fetch ?? fetch, accessToken);
}

// src/lib/download-file-to-cache-dir.ts
var import_node_path2 = require("path");
var import_promises4 = require("fs/promises");

// src/lib/paths-info.ts
async function pathsInfo(params) {
  const accessToken = checkCredentials(params);
  const repoId = toRepoId(params.repo);
  const hubUrl = params.hubUrl ?? HUB_URL;
  const url = `${hubUrl}/api/${repoId.type}s/${repoId.name}/paths-info/${encodeURIComponent(
    params.revision ?? "main"
  )}`;
  const resp = await (params.fetch ?? fetch)(url, {
    method: "POST",
    headers: {
      ...accessToken && {
        Authorization: `Bearer ${accessToken}`
      },
      Accept: "application/json",
      "Content-Type": "application/json"
    },
    body: JSON.stringify({
      paths: params.paths,
      expand: params.expand
    })
  });
  if (!resp.ok) {
    throw await createApiError(resp);
  }
  const json = await resp.json();
  if (!Array.isArray(json))
    throw new Error("malformed response: expected array");
  return json.map((item) => ({
    path: item.path,
    lfs: item.lfs,
    type: item.type,
    oid: item.oid,
    size: item.size,
    // expand fields
    securityFileStatus: item.securityFileStatus,
    lastCommit: item.lastCommit ? {
      date: new Date(item.lastCommit.date),
      title: item.lastCommit.title,
      id: item.lastCommit.id
    } : void 0
  }));
}

// src/utils/symlink.ts
var fs = __toESM(require("fs/promises"));
var path = __toESM(require("path"));
var os = __toESM(require("os"));
function expandUser(path2) {
  if (path2.startsWith("~")) {
    return path2.replace("~", os.homedir());
  }
  return path2;
}
async function createSymlink(params) {
  const abs_src = path.resolve(expandUser(params.sourcePath));
  const abs_dst = path.resolve(expandUser(params.finalPath));
  try {
    await fs.rm(abs_dst);
  } catch {
  }
  try {
    await fs.symlink(path.relative(path.dirname(abs_dst), abs_src), abs_dst);
  } catch {
    console.info(`Symlink not supported. Copying file from ${abs_src} to ${abs_dst}`);
    await fs.copyFile(abs_src, abs_dst);
  }
}

// src/lib/download-file-to-cache-dir.ts
var import_node_stream3 = require("stream");
var import_promises5 = require("stream/promises");
var import_node_fs2 = require("fs");
var REGEX_COMMIT_HASH = new RegExp("^[0-9a-f]{40}$");
function getFilePointer(storageFolder, revision, relativeFilename) {
  const snapshotPath = (0, import_node_path2.join)(storageFolder, "snapshots");
  return (0, import_node_path2.join)(snapshotPath, revision, relativeFilename);
}
async function exists(path2, followSymlinks) {
  try {
    if (followSymlinks) {
      await (0, import_promises4.stat)(path2);
    } else {
      await (0, import_promises4.lstat)(path2);
    }
    return true;
  } catch (err) {
    return false;
  }
}
async function downloadFileToCacheDir(params) {
  const revision = params.revision ?? "main";
  const cacheDir = params.cacheDir ?? getHFHubCachePath();
  const repoId = toRepoId(params.repo);
  const storageFolder = (0, import_node_path2.join)(cacheDir, getRepoFolderName(repoId));
  let commitHash;
  if (REGEX_COMMIT_HASH.test(revision)) {
    commitHash = revision;
    const pointerPath2 = getFilePointer(storageFolder, revision, params.path);
    if (await exists(pointerPath2, true))
      return pointerPath2;
  }
  const pathsInformation = await pathsInfo({
    ...params,
    paths: [params.path],
    revision,
    expand: true
  });
  if (!pathsInformation || pathsInformation.length !== 1)
    throw new Error(`cannot get path info for ${params.path}`);
  let etag;
  if (pathsInformation[0].lfs) {
    etag = pathsInformation[0].lfs.oid;
  } else {
    etag = pathsInformation[0].oid;
  }
  const pointerPath = getFilePointer(storageFolder, commitHash ?? pathsInformation[0].lastCommit.id, params.path);
  const blobPath = (0, import_node_path2.join)(storageFolder, "blobs", etag);
  if (await exists(pointerPath, true))
    return pointerPath;
  await (0, import_promises4.mkdir)((0, import_node_path2.dirname)(blobPath), { recursive: true });
  await (0, import_promises4.mkdir)((0, import_node_path2.dirname)(pointerPath), { recursive: true });
  if (await exists(blobPath)) {
    await createSymlink({ sourcePath: blobPath, finalPath: pointerPath });
    return pointerPath;
  }
  const incomplete = `${blobPath}.incomplete`;
  console.debug(`Downloading ${params.path} to ${incomplete}`);
  const blob = await downloadFile({
    ...params,
    revision: commitHash
  });
  if (!blob) {
    throw new Error(`invalid response for file ${params.path}`);
  }
  await (0, import_promises5.pipeline)(import_node_stream3.Readable.fromWeb(blob.stream()), (0, import_node_fs2.createWriteStream)(incomplete));
  await (0, import_promises4.rename)(incomplete, blobPath);
  await createSymlink({ sourcePath: blobPath, finalPath: pointerPath });
  return pointerPath;
}

// src/lib/file-exists.ts
async function fileExists(params) {
  const accessToken = checkCredentials(params);
  const repoId = toRepoId(params.repo);
  const hubUrl = params.hubUrl ?? HUB_URL;
  const url = `${hubUrl}/${repoId.type === "model" ? "" : `${repoId.type}s/`}${repoId.name}/raw/${encodeURIComponent(
    params.revision ?? "main"
  )}/${params.path}`;
  const resp = await (params.fetch ?? fetch)(url, {
    method: "HEAD",
    headers: accessToken ? { Authorization: `Bearer ${accessToken}` } : {}
  });
  if (resp.status === 404) {
    return false;
  }
  if (!resp.ok) {
    throw await createApiError(resp);
  }
  return true;
}

// src/lib/list-commits.ts
async function* listCommits(params) {
  const accessToken = checkCredentials(params);
  const repoId = toRepoId(params.repo);
  let url = `${params.hubUrl ?? HUB_URL}/api/${repoId.type}s/${repoId.name}/commits/${params.revision ?? "main"}?limit=${params.batchSize ?? 100}`;
  while (url) {
    const res = await (params.fetch ?? fetch)(url, {
      headers: accessToken ? { Authorization: `Bearer ${accessToken}` } : {}
    });
    if (!res.ok) {
      throw await createApiError(res);
    }
    const resJson = await res.json();
    for (const commit2 of resJson) {
      yield {
        oid: commit2.id,
        title: commit2.title,
        message: commit2.message,
        authors: commit2.authors.map((author) => ({
          username: author.user,
          avatarUrl: author.avatar
        })),
        date: new Date(commit2.date)
      };
    }
    const linkHeader = res.headers.get("Link");
    url = linkHeader ? parseLinkHeader(linkHeader).next : void 0;
  }
}

// src/lib/list-files.ts
async function* listFiles(params) {
  const accessToken = checkCredentials(params);
  const repoId = toRepoId(params.repo);
  let url = `${params.hubUrl || HUB_URL}/api/${repoId.type}s/${repoId.name}/tree/${params.revision || "main"}${params.path ? "/" + params.path : ""}?recursive=${!!params.recursive}&expand=${!!params.expand}`;
  while (url) {
    const res = await (params.fetch ?? fetch)(url, {
      headers: {
        accept: "application/json",
        ...accessToken ? { Authorization: `Bearer ${accessToken}` } : void 0
      }
    });
    if (!res.ok) {
      throw await createApiError(res);
    }
    const items = await res.json();
    for (const item of items) {
      yield item;
    }
    const linkHeader = res.headers.get("Link");
    url = linkHeader ? parseLinkHeader(linkHeader).next : void 0;
  }
}

// src/utils/normalizeInferenceProviderMapping.ts
function normalizeInferenceProviderMapping(hfModelId, inferenceProviderMapping) {
  if (!inferenceProviderMapping) {
    return [];
  }
  if (Array.isArray(inferenceProviderMapping)) {
    return inferenceProviderMapping.map((entry) => ({
      ...entry,
      hfModelId
    }));
  }
  return Object.entries(inferenceProviderMapping).map(([provider, mapping]) => ({
    provider,
    hfModelId,
    providerId: mapping.providerId,
    status: mapping.status,
    task: mapping.task
  }));
}

// src/lib/list-models.ts
var MODEL_EXPAND_KEYS = [
  "pipeline_tag",
  "private",
  "gated",
  "downloads",
  "likes",
  "lastModified"
];
var MODEL_EXPANDABLE_KEYS = [
  "author",
  "cardData",
  "config",
  "createdAt",
  "disabled",
  "downloads",
  "downloadsAllTime",
  "gated",
  "gitalyUid",
  "inferenceProviderMapping",
  "lastModified",
  "library_name",
  "likes",
  "model-index",
  "pipeline_tag",
  "private",
  "safetensors",
  "sha",
  // "siblings",
  "spaces",
  "tags",
  "transformersInfo"
];
async function* listModels(params) {
  const accessToken = params && checkCredentials(params);
  let totalToFetch = params?.limit ?? Infinity;
  const search = new URLSearchParams([
    ...Object.entries({
      limit: String(Math.min(totalToFetch, 500)),
      ...params?.search?.owner ? { author: params.search.owner } : void 0,
      ...params?.search?.task ? { pipeline_tag: params.search.task } : void 0,
      ...params?.search?.query ? { search: params.search.query } : void 0,
      ...params?.search?.inferenceProviders ? { inference_provider: params.search.inferenceProviders.join(",") } : void 0
    }),
    ...params?.search?.tags?.map((tag) => ["filter", tag]) ?? [],
    ...MODEL_EXPAND_KEYS.map((val) => ["expand", val]),
    ...params?.additionalFields?.map((val) => ["expand", val]) ?? []
  ]).toString();
  let url = `${params?.hubUrl || HUB_URL}/api/models?${search}`;
  while (url) {
    const res = await (params?.fetch ?? fetch)(url, {
      headers: {
        accept: "application/json",
        ...accessToken ? { Authorization: `Bearer ${accessToken}` } : void 0
      }
    });
    if (!res.ok) {
      throw await createApiError(res);
    }
    const items = await res.json();
    for (const item of items) {
      const normalizedItem = { ...item };
      if (params?.additionalFields?.includes("inferenceProviderMapping") && item.inferenceProviderMapping) {
        normalizedItem.inferenceProviderMapping = normalizeInferenceProviderMapping(
          item.id,
          item.inferenceProviderMapping
        );
      }
      yield {
        ...params?.additionalFields && pick(normalizedItem, params.additionalFields),
        id: item._id,
        name: item.id,
        private: item.private,
        task: item.pipeline_tag,
        downloads: item.downloads,
        gated: item.gated,
        likes: item.likes,
        updatedAt: new Date(item.lastModified)
      };
      totalToFetch--;
      if (totalToFetch <= 0) {
        return;
      }
    }
    const linkHeader = res.headers.get("Link");
    url = linkHeader ? parseLinkHeader(linkHeader).next : void 0;
  }
}

// src/lib/list-spaces.ts
var SPACE_EXPAND_KEYS = [
  "sdk",
  "likes",
  "private",
  "lastModified"
];
var SPACE_EXPANDABLE_KEYS = [
  "author",
  "cardData",
  "datasets",
  "disabled",
  "gitalyUid",
  "lastModified",
  "createdAt",
  "likes",
  "private",
  "runtime",
  "sdk",
  // "siblings",
  "sha",
  "subdomain",
  "tags",
  "models"
];
async function* listSpaces(params) {
  const accessToken = params && checkCredentials(params);
  const search = new URLSearchParams([
    ...Object.entries({
      limit: "500",
      ...params?.search?.owner ? { author: params.search.owner } : void 0,
      ...params?.search?.query ? { search: params.search.query } : void 0
    }),
    ...params?.search?.tags?.map((tag) => ["filter", tag]) ?? [],
    ...[...SPACE_EXPAND_KEYS, ...params?.additionalFields ?? []].map(
      (val) => ["expand", val]
    )
  ]).toString();
  let url = `${params?.hubUrl || HUB_URL}/api/spaces?${search}`;
  while (url) {
    const res = await (params?.fetch ?? fetch)(url, {
      headers: {
        accept: "application/json",
        ...accessToken ? { Authorization: `Bearer ${accessToken}` } : void 0
      }
    });
    if (!res.ok) {
      throw await createApiError(res);
    }
    const items = await res.json();
    for (const item of items) {
      yield {
        ...params?.additionalFields && pick(item, params.additionalFields),
        id: item._id,
        name: item.id,
        sdk: item.sdk,
        likes: item.likes,
        private: item.private,
        updatedAt: new Date(item.lastModified)
      };
    }
    const linkHeader = res.headers.get("Link");
    url = linkHeader ? parseLinkHeader(linkHeader).next : void 0;
  }
}

// src/lib/list-collections.ts
async function* listCollections(params) {
  const accessToken = params && checkCredentials(params);
  const searchParams = new URLSearchParams();
  let totalToFetch = params?.limit ?? Infinity;
  searchParams.append("limit", String(Math.min(totalToFetch, 100)));
  if (params?.sort) {
    searchParams.append("sort", params.sort);
  }
  if (params?.search?.owner) {
    for (const owner of params.search.owner) {
      searchParams.append("owner", owner);
    }
  }
  if (params?.search?.item) {
    for (const item of params.search.item) {
      searchParams.append("item", item);
    }
  }
  if (params?.search?.q) {
    searchParams.append("q", params.search.q);
  }
  let url = `${params?.hubUrl || HUB_URL}/api/collections?${searchParams}`;
  while (url) {
    const res = await (params?.fetch ?? fetch)(url, {
      headers: {
        accept: "application/json",
        ...accessToken ? { Authorization: `Bearer ${accessToken}` } : void 0
      }
    });
    if (!res.ok) {
      throw await createApiError(res);
    }
    const collections = await res.json();
    for (const collection of collections) {
      yield collection;
      totalToFetch--;
      if (totalToFetch <= 0) {
        return;
      }
    }
    const linkHeader = res.headers.get("Link");
    url = linkHeader ? parseLinkHeader(linkHeader).next : void 0;
  }
}

// src/lib/model-info.ts
async function modelInfo(params) {
  const accessToken = params && checkCredentials(params);
  const search = new URLSearchParams([
    ...MODEL_EXPAND_KEYS.map((val) => ["expand", val]),
    ...params?.additionalFields?.map((val) => ["expand", val]) ?? []
  ]).toString();
  const response = await (params.fetch || fetch)(
    `${params?.hubUrl || HUB_URL}/api/models/${params.name}/revision/${encodeURIComponent(
      params.revision ?? "HEAD"
    )}?${search.toString()}`,
    {
      headers: {
        ...accessToken ? { Authorization: `Bearer ${accessToken}` } : {},
        Accepts: "application/json"
      }
    }
  );
  if (!response.ok) {
    throw await createApiError(response);
  }
  const data = await response.json();
  const normalizedData = { ...data };
  if (params?.additionalFields?.includes("inferenceProviderMapping") && data.inferenceProviderMapping) {
    normalizedData.inferenceProviderMapping = normalizeInferenceProviderMapping(data.id, data.inferenceProviderMapping);
  }
  return {
    ...params?.additionalFields && pick(normalizedData, params.additionalFields),
    id: data._id,
    name: data.id,
    private: data.private,
    task: data.pipeline_tag,
    downloads: data.downloads,
    gated: data.gated,
    likes: data.likes,
    updatedAt: new Date(data.lastModified)
  };
}

// src/lib/oauth-handle-redirect.ts
async function oauthHandleRedirect(opts) {
  if (typeof window === "undefined" && !opts?.redirectedUrl) {
    throw new Error("oauthHandleRedirect is only available in the browser, unless you provide redirectedUrl");
  }
  if (typeof localStorage === "undefined" && (!opts?.nonce || !opts?.codeVerifier)) {
    throw new Error(
      "oauthHandleRedirect requires localStorage to be available, unless you provide nonce and codeVerifier"
    );
  }
  const redirectedUrl = opts?.redirectedUrl ?? window.location.href;
  const searchParams = (() => {
    try {
      return new URL(redirectedUrl).searchParams;
    } catch (err) {
      throw new Error("Failed to parse redirected URL: " + redirectedUrl);
    }
  })();
  const [error, errorDescription] = [searchParams.get("error"), searchParams.get("error_description")];
  if (error) {
    throw new Error(`${error}: ${errorDescription}`);
  }
  const code = searchParams.get("code");
  const nonce = opts?.nonce ?? localStorage.getItem("huggingface.co:oauth:nonce");
  if (!code) {
    throw new Error("Missing oauth code from query parameters in redirected URL: " + redirectedUrl);
  }
  if (!nonce) {
    throw new Error("Missing oauth nonce from localStorage");
  }
  const codeVerifier = opts?.codeVerifier ?? localStorage.getItem("huggingface.co:oauth:code_verifier");
  if (!codeVerifier) {
    throw new Error("Missing oauth code_verifier from localStorage");
  }
  const state = searchParams.get("state");
  if (!state) {
    throw new Error("Missing oauth state from query parameters in redirected URL");
  }
  let parsedState;
  try {
    parsedState = JSON.parse(state);
  } catch {
    throw new Error("Invalid oauth state in redirected URL, unable to parse JSON: " + state);
  }
  if (parsedState.nonce !== nonce) {
    throw new Error("Invalid oauth state in redirected URL");
  }
  const hubUrl = opts?.hubUrl || HUB_URL;
  const openidConfigUrl = `${new URL(hubUrl).origin}/.well-known/openid-configuration`;
  const openidConfigRes = await fetch(openidConfigUrl, {
    headers: {
      Accept: "application/json"
    }
  });
  if (!openidConfigRes.ok) {
    throw await createApiError(openidConfigRes);
  }
  const openidConfig = await openidConfigRes.json();
  const tokenRes = await fetch(openidConfig.token_endpoint, {
    method: "POST",
    headers: {
      "Content-Type": "application/x-www-form-urlencoded"
    },
    body: new URLSearchParams({
      grant_type: "authorization_code",
      code,
      redirect_uri: parsedState.redirectUri,
      code_verifier: codeVerifier
    }).toString()
  });
  if (!opts?.codeVerifier) {
    localStorage.removeItem("huggingface.co:oauth:code_verifier");
  }
  if (!opts?.nonce) {
    localStorage.removeItem("huggingface.co:oauth:nonce");
  }
  if (!tokenRes.ok) {
    throw await createApiError(tokenRes);
  }
  const token = await tokenRes.json();
  const accessTokenExpiresAt = new Date(Date.now() + token.expires_in * 1e3);
  const userInfoRes = await fetch(openidConfig.userinfo_endpoint, {
    headers: {
      Authorization: `Bearer ${token.access_token}`
    }
  });
  if (!userInfoRes.ok) {
    throw await createApiError(userInfoRes);
  }
  const userInfo = await userInfoRes.json();
  return {
    accessToken: token.access_token,
    accessTokenExpiresAt,
    userInfo,
    state: parsedState.state,
    scope: token.scope
  };
}
async function oauthHandleRedirectIfPresent(opts) {
  if (typeof window === "undefined" && !opts?.redirectedUrl) {
    throw new Error("oauthHandleRedirect is only available in the browser, unless you provide redirectedUrl");
  }
  if (typeof localStorage === "undefined" && (!opts?.nonce || !opts?.codeVerifier)) {
    throw new Error(
      "oauthHandleRedirect requires localStorage to be available, unless you provide nonce and codeVerifier"
    );
  }
  const searchParams = new URLSearchParams(opts?.redirectedUrl ?? window.location.search);
  if (searchParams.has("error")) {
    return oauthHandleRedirect(opts);
  }
  if (searchParams.has("code")) {
    if (!localStorage.getItem("huggingface.co:oauth:nonce")) {
      console.warn(
        "Missing oauth nonce from localStorage. This can happen when the user refreshes the page after logging in, without changing the URL."
      );
      return false;
    }
    return oauthHandleRedirect(opts);
  }
  return false;
}

// src/lib/oauth-login-url.ts
async function oauthLoginUrl(opts) {
  if (typeof window === "undefined" && (!opts?.redirectUrl || !opts?.clientId)) {
    throw new Error("oauthLogin is only available in the browser, unless you provide clientId and redirectUrl");
  }
  if (typeof localStorage === "undefined" && !opts?.localStorage) {
    throw new Error(
      "oauthLogin requires localStorage to be available in the context, unless you provide a localStorage empty object as argument"
    );
  }
  const hubUrl = opts?.hubUrl || HUB_URL;
  const openidConfigUrl = `${new URL(hubUrl).origin}/.well-known/openid-configuration`;
  const openidConfigRes = await fetch(openidConfigUrl, {
    headers: {
      Accept: "application/json"
    }
  });
  if (!openidConfigRes.ok) {
    throw await createApiError(openidConfigRes);
  }
  const opendidConfig = await openidConfigRes.json();
  const newNonce = globalThis.crypto.randomUUID();
  const newCodeVerifier = globalThis.crypto.randomUUID() + globalThis.crypto.randomUUID();
  if (opts?.localStorage) {
    if (opts.localStorage.codeVerifier !== void 0 && opts.localStorage.codeVerifier !== null) {
      throw new Error(
        "localStorage.codeVerifier must be initially set to null or undefined, and will be filled by oauthLoginUrl"
      );
    }
    if (opts.localStorage.nonce !== void 0 && opts.localStorage.nonce !== null) {
      throw new Error(
        "localStorage.nonce must be initially set to null or undefined, and will be filled by oauthLoginUrl"
      );
    }
    opts.localStorage.codeVerifier = newCodeVerifier;
    opts.localStorage.nonce = newNonce;
  } else {
    localStorage.setItem("huggingface.co:oauth:nonce", newNonce);
    localStorage.setItem("huggingface.co:oauth:code_verifier", newCodeVerifier);
  }
  const redirectUri = opts?.redirectUrl || (typeof window !== "undefined" ? window.location.href : void 0);
  if (!redirectUri) {
    throw new Error("Missing redirectUrl");
  }
  const state = JSON.stringify({
    nonce: newNonce,
    redirectUri,
    state: opts?.state
  });
  const variables = (
    // @ts-expect-error window.huggingface is defined inside static Spaces.
    typeof window !== "undefined" ? window.huggingface?.variables ?? null : null
  );
  const clientId = opts?.clientId || variables?.OAUTH_CLIENT_ID;
  if (!clientId) {
    if (variables) {
      throw new Error("Missing clientId, please add hf_oauth: true to the README.md's metadata in your static Space");
    }
    throw new Error("Missing clientId");
  }
  const challenge = base64FromBytes(
    new Uint8Array(await globalThis.crypto.subtle.digest("SHA-256", new TextEncoder().encode(newCodeVerifier)))
  ).replace(/[+]/g, "-").replace(/[/]/g, "_").replace(/=/g, "");
  return `${opendidConfig.authorization_endpoint}?${new URLSearchParams({
    client_id: clientId,
    scope: opts?.scopes || variables?.OAUTH_SCOPES || "openid profile",
    response_type: "code",
    redirect_uri: redirectUri,
    state,
    code_challenge: challenge,
    code_challenge_method: "S256"
  }).toString()}`;
}

// src/utils/typedInclude.ts
function typedInclude(arr, v) {
  return arr.includes(v);
}

// src/utils/omit.ts
function omit(o, props) {
  const propsArr = Array.isArray(props) ? props : [props];
  const letsKeep = Object.keys(o).filter((prop) => !typedInclude(propsArr, prop));
  return pick(o, letsKeep);
}

// src/utils/typedEntries.ts
function typedEntries(obj) {
  return Object.entries(obj);
}

// src/lib/parse-safetensors-metadata.ts
var SAFETENSORS_FILE = "model.safetensors";
var SAFETENSORS_INDEX_FILE = "model.safetensors.index.json";
var RE_SAFETENSORS_FILE = /\.safetensors$/;
var RE_SAFETENSORS_INDEX_FILE = /\.safetensors\.index\.json$/;
var RE_SAFETENSORS_SHARD_FILE = /^(?<prefix>(?<basePrefix>.*?)[_-])(?<shard>\d{5})-of-(?<total>\d{5})\.safetensors$/;
function parseSafetensorsShardFilename(filename) {
  const match = RE_SAFETENSORS_SHARD_FILE.exec(filename);
  if (match && match.groups) {
    return {
      prefix: match.groups["prefix"],
      basePrefix: match.groups["basePrefix"],
      shard: match.groups["shard"],
      total: match.groups["total"]
    };
  }
  return null;
}
var PARALLEL_DOWNLOADS = 20;
var MAX_HEADER_LENGTH = 25e6;
var SafetensorParseError = class extends Error {
};
async function fetchModelConfig(params) {
  try {
    const configBlob = await downloadFile({
      ...params,
      path: "config.json"
    });
    if (!configBlob) {
      return null;
    }
    const config = JSON.parse(await configBlob.text());
    return config;
  } catch (error) {
    return null;
  }
}
async function parseSingleFile(path2, params) {
  const blob = await downloadFile({ ...params, path: path2 });
  if (!blob) {
    throw new SafetensorParseError(`Failed to parse file ${path2}: failed to fetch safetensors header length.`);
  }
  const bufLengthOfHeaderLE = await blob.slice(0, 8).arrayBuffer();
  const lengthOfHeader = new DataView(bufLengthOfHeaderLE).getBigUint64(0, true);
  if (lengthOfHeader <= 0) {
    throw new SafetensorParseError(`Failed to parse file ${path2}: safetensors header is malformed.`);
  }
  if (lengthOfHeader > MAX_HEADER_LENGTH) {
    throw new SafetensorParseError(
      `Failed to parse file ${path2}: safetensor header is too big. Maximum supported size is ${MAX_HEADER_LENGTH} bytes.`
    );
  }
  try {
    const header = JSON.parse(await blob.slice(8, 8 + Number(lengthOfHeader)).text());
    return header;
  } catch (err) {
    throw new SafetensorParseError(`Failed to parse file ${path2}: safetensors header is not valid JSON.`);
  }
}
async function parseShardedIndex(path2, params) {
  const indexBlob = await downloadFile({
    ...params,
    path: path2
  });
  if (!indexBlob) {
    throw new SafetensorParseError(`Failed to parse file ${path2}: failed to fetch safetensors index.`);
  }
  try {
    const index = JSON.parse(await indexBlob.slice(0, 1e7).text());
    return index;
  } catch (error) {
    throw new SafetensorParseError(`Failed to parse file ${path2}: not a valid JSON.`);
  }
}
async function fetchAllHeaders(path2, index, params) {
  const pathPrefix = path2.slice(0, path2.lastIndexOf("/") + 1);
  const filenames = [...new Set(Object.values(index.weight_map))];
  const shardedMap = Object.fromEntries(
    await promisesQueue(
      filenames.map(
        (filename) => async () => [filename, await parseSingleFile(pathPrefix + filename, params)]
      ),
      PARALLEL_DOWNLOADS
    )
  );
  return shardedMap;
}
async function parseSafetensorsMetadata(params) {
  const repoId = toRepoId(params.repo);
  if (repoId.type !== "model") {
    throw new TypeError("Only model repos should contain safetensors files.");
  }
  const modelConfig = params.computeParametersCount ? await fetchModelConfig(params) : null;
  const quantConfig = modelConfig?.quantization_config;
  if (params.path && RE_SAFETENSORS_FILE.test(params.path) || await fileExists({ ...params, path: SAFETENSORS_FILE })) {
    const header = await parseSingleFile(params.path ?? SAFETENSORS_FILE, params);
    return {
      sharded: false,
      header,
      ...params.computeParametersCount ? {
        parameterCount: computeNumOfParamsByDtypeSingleFile(header, quantConfig),
        parameterTotal: (
          /// shortcut: get param count directly from metadata
          header.__metadata__.total_parameters ? typeof header.__metadata__.total_parameters === "number" ? header.__metadata__.total_parameters : typeof header.__metadata__.total_parameters === "string" ? parseInt(header.__metadata__.total_parameters) : void 0 : void 0
        )
      } : void 0
    };
  } else if (params.path && RE_SAFETENSORS_INDEX_FILE.test(params.path) || await fileExists({ ...params, path: SAFETENSORS_INDEX_FILE })) {
    const path2 = params.path ?? SAFETENSORS_INDEX_FILE;
    const index = await parseShardedIndex(path2, params);
    const shardedMap = await fetchAllHeaders(path2, index, params);
    return {
      sharded: true,
      index,
      headers: shardedMap,
      ...params.computeParametersCount ? {
        parameterCount: computeNumOfParamsByDtypeSharded(shardedMap, quantConfig),
        parameterTotal: (
          /// shortcut: get param count directly from metadata
          index.metadata?.total_parameters ? typeof index.metadata.total_parameters === "number" ? index.metadata.total_parameters : typeof index.metadata.total_parameters === "string" ? parseInt(index.metadata.total_parameters) : void 0 : void 0
        )
      } : void 0
    };
  } else {
    throw new Error("model id does not seem to contain safetensors weights");
  }
}
function isQuantizedTensor(tensorName, quantConfig) {
  if (!quantConfig || !quantConfig.modules_to_not_convert) {
    return false;
  }
  for (const pattern of quantConfig.modules_to_not_convert) {
    const regexPattern = pattern.replace(/\*/g, ".*");
    const regex = new RegExp(regexPattern);
    if (regex.test(tensorName)) {
      return false;
    }
  }
  return true;
}
function getQuantizationMultiplier(tensorName, dtype, quantConfig) {
  if (!quantConfig || !isQuantizedTensor(tensorName, quantConfig)) {
    return 1;
  }
  switch (quantConfig.quant_method) {
    case "mxfp4":
      if (dtype === "U8" && tensorName.includes("_blocks")) {
        return 2;
      }
      return 1;
    case "gptq":
    case "awq":
      if (quantConfig.bits === 4 && dtype === "U8") {
        return 2;
      }
      if (quantConfig.bits === 2 && dtype === "U8") {
        return 4;
      }
      return 1;
    case "bitsandbytes":
      if (quantConfig.load_in_4bit && dtype === "U8") {
        return 2;
      }
      if (quantConfig.load_in_8bit) {
        return 1;
      }
      return 1;
    default:
      if (quantConfig.load_in_4bit && dtype === "U8") {
        return 2;
      }
      if (quantConfig.bits === 4 && dtype === "U8") {
        return 2;
      }
      return 1;
  }
}
function computeNumOfParamsByDtypeSingleFile(header, quantConfig) {
  const counter = {};
  const tensors = omit(header, "__metadata__");
  for (const [tensorName, v] of typedEntries(tensors)) {
    if (v.shape.length === 0) {
      continue;
    }
    const elements = v.shape.reduce((a, b) => a * b);
    const multiplier = quantConfig ? getQuantizationMultiplier(tensorName, v.dtype, quantConfig) : 1;
    counter[v.dtype] = (counter[v.dtype] ?? 0) + elements * multiplier;
  }
  return counter;
}
function computeNumOfParamsByDtypeSharded(shardedMap, quantConfig) {
  const counter = {};
  for (const header of Object.values(shardedMap)) {
    for (const [k, v] of typedEntries(computeNumOfParamsByDtypeSingleFile(header, quantConfig))) {
      counter[k] = (counter[k] ?? 0) + (v ?? 0);
    }
  }
  return counter;
}

// src/lib/repo-exists.ts
async function repoExists(params) {
  const repoId = toRepoId(params.repo);
  const res = await (params.fetch ?? fetch)(
    `${params.hubUrl ?? HUB_URL}/api/${repoId.type}s/${repoId.name}?expand[]=likes`,
    {
      method: "GET",
      headers: {
        ...params.accessToken && {
          Authorization: `Bearer ${params.accessToken}`
        }
      }
    }
  );
  if (res.status === 404 || res.status === 401) {
    return false;
  }
  if (!res.ok) {
    throw await createApiError(res);
  }
  return true;
}

// src/lib/space-info.ts
async function spaceInfo(params) {
  const accessToken = params && checkCredentials(params);
  const search = new URLSearchParams([
    ...SPACE_EXPAND_KEYS.map((val) => ["expand", val]),
    ...params?.additionalFields?.map((val) => ["expand", val]) ?? []
  ]).toString();
  const response = await (params.fetch || fetch)(
    `${params?.hubUrl || HUB_URL}/api/spaces/${params.name}/revision/${encodeURIComponent(
      params.revision ?? "HEAD"
    )}?${search.toString()}`,
    {
      headers: {
        ...accessToken ? { Authorization: `Bearer ${accessToken}` } : {},
        Accepts: "application/json"
      }
    }
  );
  if (!response.ok) {
    throw await createApiError(response);
  }
  const data = await response.json();
  return {
    ...params?.additionalFields && pick(data, params.additionalFields),
    id: data._id,
    name: data.id,
    sdk: data.sdk,
    likes: data.likes,
    private: data.private,
    updatedAt: new Date(data.lastModified)
  };
}

// src/lib/snapshot-download.ts
var import_node_path3 = require("path");
var import_promises6 = require("fs/promises");
var DEFAULT_REVISION = "main";
async function snapshotDownload(params) {
  let cacheDir;
  if (params.cacheDir) {
    cacheDir = params.cacheDir;
  } else {
    cacheDir = getHFHubCachePath();
  }
  let revision;
  if (params.revision) {
    revision = params.revision;
  } else {
    revision = DEFAULT_REVISION;
  }
  const repoId = toRepoId(params.repo);
  let repoInfo;
  switch (repoId.type) {
    case "space":
      repoInfo = await spaceInfo({
        ...params,
        name: repoId.name,
        additionalFields: ["sha"],
        revision
      });
      break;
    case "dataset":
      repoInfo = await datasetInfo({
        ...params,
        name: repoId.name,
        additionalFields: ["sha"],
        revision
      });
      break;
    case "model":
      repoInfo = await modelInfo({
        ...params,
        name: repoId.name,
        additionalFields: ["sha"],
        revision
      });
      break;
    default:
      throw new Error(`invalid repository type ${repoId.type}`);
  }
  const commitHash = repoInfo.sha;
  const storageFolder = (0, import_node_path3.join)(cacheDir, getRepoFolderName(repoId));
  const snapshotFolder = (0, import_node_path3.join)(storageFolder, "snapshots", commitHash);
  if (revision !== commitHash) {
    const refPath = (0, import_node_path3.join)(storageFolder, "refs", revision);
    await (0, import_promises6.mkdir)((0, import_node_path3.dirname)(refPath), { recursive: true });
    await (0, import_promises6.writeFile)(refPath, commitHash);
  }
  const cursor = listFiles({
    ...params,
    repo: params.repo,
    recursive: true,
    revision: repoInfo.sha
  });
  for await (const entry of cursor) {
    switch (entry.type) {
      case "file":
        await downloadFileToCacheDir({
          ...params,
          path: entry.path,
          revision: commitHash,
          cacheDir
        });
        break;
      case "directory":
        await (0, import_promises6.mkdir)((0, import_node_path3.join)(snapshotFolder, entry.path), { recursive: true });
        break;
      default:
        throw new Error(`unknown entry type: ${entry.type}`);
    }
  }
  return snapshotFolder;
}

// src/lib/upload-file.ts
function uploadFile(params) {
  const path2 = params.file instanceof URL ? params.file.pathname.split("/").at(-1) ?? "file" : "path" in params.file ? params.file.path : params.file.name;
  return commit({
    ...params.accessToken ? { accessToken: params.accessToken } : { credentials: params.credentials },
    repo: params.repo,
    operations: [
      {
        operation: "addOrUpdate",
        path: path2,
        content: "content" in params.file ? params.file.content : params.file
      }
    ],
    title: params.commitTitle ?? `Add ${path2}`,
    description: params.commitDescription,
    hubUrl: params.hubUrl,
    branch: params.branch,
    isPullRequest: params.isPullRequest,
    parentCommit: params.parentCommit,
    fetch: params.fetch,
    useWebWorkers: params.useWebWorkers,
    abortSignal: params.abortSignal,
    useXet: params.useXet
  });
}

// src/lib/upload-files.ts
function uploadFiles(params) {
  return commit({
    ...params.accessToken ? { accessToken: params.accessToken } : { credentials: params.credentials },
    repo: params.repo,
    operations: params.files.map((file) => ({
      operation: "addOrUpdate",
      path: file instanceof URL ? file.pathname.split("/").at(-1) ?? "file" : "path" in file ? file.path : file.name,
      content: "content" in file ? file.content : file
    })),
    title: params.commitTitle ?? `Add ${params.files.length} files`,
    description: params.commitDescription,
    hubUrl: params.hubUrl,
    branch: params.branch,
    isPullRequest: params.isPullRequest,
    parentCommit: params.parentCommit,
    fetch: params.fetch,
    useWebWorkers: params.useWebWorkers,
    abortSignal: params.abortSignal,
    useXet: params.useXet
  });
}

// src/lib/upload-files-with-progress.ts
var multipartUploadTracking = /* @__PURE__ */ new WeakMap();
async function* uploadFilesWithProgress(params) {
  return yield* commitIter({
    ...params.accessToken ? { accessToken: params.accessToken } : { credentials: params.credentials },
    repo: params.repo,
    operations: params.files.map((file) => ({
      operation: "addOrUpdate",
      path: file instanceof URL ? file.pathname.split("/").at(-1) ?? "file" : "path" in file ? file.path : file.name,
      content: "content" in file ? file.content : file
    })),
    title: params.commitTitle ?? `Add ${params.files.length} files`,
    description: params.commitDescription,
    hubUrl: params.hubUrl,
    branch: params.branch,
    isPullRequest: params.isPullRequest,
    parentCommit: params.parentCommit,
    useWebWorkers: params.useWebWorkers,
    abortSignal: params.abortSignal,
    useXet: params.useXet,
    fetch: params.useXet === true ? (
      // no need for custom fetch function if we use Xet, as we already have progress events in the commit function for file uploads in that case
      void 0
    ) : async (input, init2) => {
      if (!init2) {
        return fetch(input);
      }
      if (!typedInclude(["PUT", "POST"], init2.method) || !("progressHint" in init2) || !init2.progressHint || typeof XMLHttpRequest === "undefined" || typeof input !== "string" || !(init2.body instanceof ArrayBuffer) && !(init2.body instanceof Blob) && !(init2.body instanceof File) && typeof init2.body !== "string") {
        return fetch(input, init2);
      }
      const progressHint = init2.progressHint;
      const progressCallback = progressHint.progressCallback;
      const xhr = new XMLHttpRequest();
      xhr.upload.addEventListener("progress", (event) => {
        if (event.lengthComputable) {
          if (progressHint.part !== void 0) {
            let tracking = multipartUploadTracking.get(progressCallback);
            if (!tracking) {
              tracking = { numParts: progressHint.numParts, partsProgress: {} };
              multipartUploadTracking.set(progressCallback, tracking);
            }
            tracking.partsProgress[progressHint.part] = event.loaded / event.total;
            let totalProgress = 0;
            for (const partProgress of Object.values(tracking.partsProgress)) {
              totalProgress += partProgress;
            }
            if (totalProgress === tracking.numParts) {
              progressCallback(0.9999999999);
            } else {
              progressCallback(totalProgress / tracking.numParts);
            }
          } else {
            if (event.loaded === event.total) {
              progressCallback(0.9999999999);
            } else {
              progressCallback(event.loaded / event.total);
            }
          }
        }
      });
      xhr.open(init2.method, input, true);
      if (init2.headers) {
        const headers = new Headers(init2.headers);
        headers.forEach((value, key) => {
          xhr.setRequestHeader(key, value);
        });
      }
      init2.signal?.throwIfAborted();
      xhr.send(init2.body);
      return new Promise((resolve3, reject) => {
        xhr.addEventListener("load", () => {
          resolve3(
            new Response(xhr.responseText, {
              status: xhr.status,
              statusText: xhr.statusText,
              headers: Object.fromEntries(
                xhr.getAllResponseHeaders().trim().split("\n").map((header) => [
                  header.slice(0, header.indexOf(":")),
                  header.slice(header.indexOf(":") + 1).trim()
                ])
              )
            })
          );
        });
        xhr.addEventListener("error", () => {
          reject(new Error(xhr.statusText));
        });
        if (init2.signal) {
          init2.signal.addEventListener("abort", () => {
            xhr.abort();
            try {
              init2.signal?.throwIfAborted();
            } catch (err) {
              reject(err);
            }
          });
        }
      });
    }
  });
}

// src/lib/who-am-i.ts
async function whoAmI(params) {
  const accessToken = checkCredentials(params);
  const res = await (params.fetch ?? fetch)(`${params.hubUrl ?? HUB_URL}/api/whoami-v2`, {
    headers: {
      Authorization: `Bearer ${accessToken}`
    }
  });
  if (!res.ok) {
    throw await createApiError(res);
  }
  const response = await res.json();
  if (typeof response.auth.accessToken?.createdAt === "string") {
    response.auth.accessToken.createdAt = new Date(response.auth.accessToken.createdAt);
  }
  return response;
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  DATASET_EXPANDABLE_KEYS,
  DATASET_EXPAND_KEYS,
  DEFAULT_REVISION,
  HUB_URL,
  HubApiError,
  InvalidApiResponseFormatError,
  MODEL_EXPANDABLE_KEYS,
  MODEL_EXPAND_KEYS,
  REGEX_COMMIT_HASH,
  REPO_ID_SEPARATOR,
  RE_SAFETENSORS_FILE,
  RE_SAFETENSORS_INDEX_FILE,
  RE_SAFETENSORS_SHARD_FILE,
  SAFETENSORS_FILE,
  SAFETENSORS_INDEX_FILE,
  SPACE_EXPANDABLE_KEYS,
  SPACE_EXPAND_KEYS,
  __internal_XetBlob,
  __internal_sha256,
  checkRepoAccess,
  commit,
  commitIter,
  countCommits,
  createBranch,
  createCollection,
  createRepo,
  datasetInfo,
  deleteBranch,
  deleteCollection,
  deleteFile,
  deleteFiles,
  deleteRepo,
  downloadFile,
  downloadFileToCacheDir,
  fileDownloadInfo,
  fileExists,
  getBlobStat,
  getHFHubCachePath,
  getRepoFolderName,
  listCollections,
  listCommits,
  listDatasets,
  listFiles,
  listModels,
  listSpaces,
  modelInfo,
  oauthHandleRedirect,
  oauthHandleRedirectIfPresent,
  oauthLoginUrl,
  parseRepoType,
  parseSafetensorsMetadata,
  parseSafetensorsShardFilename,
  pathsInfo,
  repoExists,
  scanCacheDir,
  scanCachedRepo,
  scanRefsDir,
  scanSnapshotDir,
  snapshotDownload,
  spaceInfo,
  uploadFile,
  uploadFiles,
  uploadFilesWithProgress,
  whoAmI
});
